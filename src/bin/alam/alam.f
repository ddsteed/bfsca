C * JUL 27 2013 - RDS - S,P,D,F,G,H,I-TYPE GAUSSIAN BASIS ARE ALLOWED
C *                     MODIFY ITYPE FROM GAMESS 2013
C * JUN 23 2013 - RDS - S,P,D,F,G-TYPE GAUSSIAN BASIS ARE ALLOWED
C * DEC 05 2005 - RDS - FIX THE BUG OF PI-ORBITAL
C * AUG 29 2005 - RDS - MODIFY ITYPE FORMAT OF GAMESS
C *                     LARGE R-FIT MODIFICATION TO OVERCOME OVERFLOW
C * AUG 11 1985 - TLG - MOEXP CALCULATES THE SPHERICAL HARMONIC EXPANSIONS OF MO
C *                     CARTESIAN GTO ARE ALLOWED
C * JUN 01 1985 - AF  - MO OPTION MODIFIED TO ALLOW OUTPUT FOR LA CODE
C * JUN 01 1981 - AF  - MO EXPANSION ADDED
C * MAR 01 1979 - MAM - CALCULATE MO CHARGE DISTRIBUTION FOR A LINEAR MOLECULE

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL TIME1
      CHARACTER*4 ILBL

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12,NLAMMX=41)
      PARAMETER (LAMMX=40,NTLAMX=21)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /LCAOMO/D(NCBFNX,NOCCX)
      COMMON /INDATA1/NTYPE(NCBFNX),NFIRST(NCBFNX),NLAST(NCBFNX)
     $     ,NR(NTMX,3),MORB(NOCCX),NBFXX,NTXX
     $     ,NGXX,NCXX,NON,NCBFN,NOCC
      COMMON /INDATA2/ VLIST(NCMX,4),ETAG(NGMX,5)
      COMMON /PLTMSH/ XMAX,ZMAX,XSTEP,XVAL,ZVAL,NXPTS,NZPTS
      COMMON /PRMANG/ QANG(NQANGX),SN(NQANGX),CS(NQANGX),PLSNQA(NQANGX
     $     ,0:LAMMX)

      COMMON /LABELS/  ILBL(18)
      COMMON /NMBRS /  PI, PITERM, PITERN, ICANON
      COMMON /ALAMDA/ A0(NRPTSX),ASM,PSM,QSM,CONT2,RMAX
      COMMON /ANGSTF/ ANGLE(NQANGX),PLAM(NQANGX,NTLAMX),NQUAD
      COMMON /BASIS/ IBSS
      COMMON /FMAT/ F(NQANGX,NRPTSX)
      COMMON /LAMDAT/ LAMMIN, LAMMAX,LAMSTP,NLAM
      COMMON /MODAT1/ ETA(NOCCX,NNUCMX,NSTOMX),N(NOCCX,NNUCMX,NSTOMX)
     $     ,L(NOCCX,NNUCMX,NSTOMX),M(NOCCX,NNUCMX,NSTOMX)
      COMMON /MODAT2/ B(NNUCMX),Z(NNUCMX),C(NOCCX,NNUCMX,NSTOMX),
     $     NOCP(NOCCX),NBFN(NOCCX,NNUCMX),NCT,NMO,IPARI(NOCCX)
      COMMON /MOLTYP/ IHETRO
      COMMON /RDATA/ R(NRPTSX),NRPTS
      COMMON /SPPRJ/ RVAL,MSYM(NOCCX),MOIND,LLL,INDCON,MMM,ITEST
      CHARACTER TITLE(72)

C *-
C *                  >>>>>> PARAMETER CONSTANT DEFINITONS <<<<<<<
C *
C * NQANGMX :== MAX # OF ANGLES IN THE THETA QUADRATURE.
C * NRPTSX  :== MAX # OF POINTS IN THE R-MESH 
C * NNUCMX  :== MAX # OF NUCLEI THAT THE CODE WILL HANDLE 
C *             (THIS IS ALSO THE MAX. # OF CENTERS FOR A STO
C *             CALCULATION, BUT NOT FOR A GTO CALCULATION.)
C * NSTOMX  :== MAX # OF STO FCNS. ON ONE CENTER.
C * LAMMX   :== MAX VALUE OF LAMDA FOR THE LEGENDRE FCNS. STORED
C *             IN THE BLOCK DATA TABEL
C * NTLAMX  :== MAX # OF LAMDAS IN THE ARRAYS USED WHEN ITEST=1 
C * NLAMMX  :== MAX # OF LAMDAS IN THE ARRAYS USED WHEN ITEST .NE. 1 
C * NGMX    :== MAX # OF GAUSSIAN PRIMITIVES 
C * NCBFNX  :== MAX # OF CONTRACTED GAUSSIANS 
C * NOCCX   :== MAX # OF OCCUPIED ORBITALS (11)
C * NCMX    :== MAX # OF CENTERS IN THE XZ-PLANE FOR GTOS
C *-/

C * DATA DESCRIPTION OF SWITCHES AND OPTIONS
C *
C * IHETRO = 1 FOR HETERONUCLEAR SYMMETRY = 0 ELSE
C * IFDSK = 1 IF FUNCTION F IS ON DISK ON FSET 4
C * IWRTF = 1 IF CODE IS TO WRITE F TO FSET 2
C * ISTORA = 1 IF CODE IS TO WRITE A COEFFS TO FSET 3
C * NEWRS = 1 IF WE ARE TO CALCULATE F AT ANY NEW R VALUES
C * IADSK = 1 IF THERE ARE SOME ALAMDA ON FSET 8
C * NOTE IF IADSK = 1 THEN LAMDA = 0 MUST BE THE FIRST LAMDA
C * FILE ON FSET 8
C * IPROJ = 0 DO NOT DO MOEXP
C *       = 1 DO ONLY MOEXP (NO CHARGE DENSITY OR ALAM)
C *       = 2 DO MOEXP AND ANY OTHER CALCULATIONS
C *       = same as above but negative, then output in LinAlg form
C * FOR STO FCNS INDCON DENOTES THE MO AND BASIS FUNCTION CONVENTIONS
C * INDCON = 1 FOR MCLEAN AND YOSHIMINE CONVENTIONS
C * INDCON = 2 FOR CADE ET AL CONVENTIONS
C * INDCON = 3 FOR FRAGA AND RANSIL CONVENTIONS
C * IF IHETRO = 0, DO NOT INPUT COEFFICIENTS FOR RIGHTMOST CENTER
C * IBSS = 0 STO BASIS
C * IBSS = 1 CARTESIAN GTO BASIS
C * IPLOT = 1 THIS PRODUCES THE CHARGE DENSITY ON A CARTESIAN MESH
C *           OF POINTS (X,Z) SUITABLE FOR SURFACE PLOTS.  (IF THIS
C *           OPTION IS CHOSEN, NO OTHER QUANTITIES WILL BE CALCULATED.)
C *           THE CHARGE DENSITY IS WRITTEN TO UNIT 2.
C * NPRNT = 0 THIS OPTION IS ONLY USED WITH GTOS.  IT CAUSES A MINIMUM OF
C *           OUTPUT TO BE WRITTEN TO UNIT 6 INVOLVING GTO:MO OVERLAPS.
C *       = 1 MORE INFORMATION IS PRINTED.
C *       = 2 THIS PRINTS ALL THE AVAILABLE INFORMATION INCLUDING THE 
C *           OVERLAP MATRIX OF "ATOMIC FCNS".
C * ITEST = 1 IF THIS OPTION IS CHOSEN, THE QUADRATURE ANGLES AND LEGENDRE
C *           FCNS. ARE CALCULATED.  (THIS INVOKES THE ORIGINAL CODING.)
C *           FOR ANY OTHER VALUE OF ITEST, THE QUADRATURE ANGLES AND ALL
C *           FUNCTIONS OF THETA ARE LOOKED UP IN THE BLOCK DATA TABLE.
C *           THE ASSOCIATED LEGENDRE FCNS. NEEDED FOR THE MOEXP OPTION
C *           WILL BE CALCULATED IF NECESSARY.
C *
C * CODE IS SET UP TO DO A NQUAD = 32 POINT QUADRATURE
C * UP TO 3 NUCLEI ARE PERMITTED
C *
C *
C * DESCRIPTION OF UNIT 5 INPUT
C *
C * READ  TITLE
C *
C * READ         IHETRO,IFDSK,IWRTF,IPNCHA,ISTORA,INDCON,NEWRS,IADSK,
C * (36I2)       IPROJ,IBSS,IPLOT,NPRNT,ITEST
C *
C * IF ((ABS(IPROJ) .NE. 1) .AND. (IPLOT .NE. 1) THEN
C *   READ LAMMIN,LAMMAX                 LAMMIN = MIN. VALUE OF LAMDA FOR EXP
C *   (2I5)                              LAMMAX = MAX VALUE OF LAMDA FOR EXP.
C * END IF
C *
C * IF ((NEWRS .NE. 0) .OR. (IPLOT .EQ. 1) THEN
C *   IF (IPLOT .EQ. 1) THEN
C *     READ XMAX,ZMAX,XSTEP             XMAX = MAX. VALUE OF X FOR SURFACE
C *     (*)                                     PLOT
C *                                      ZMAX = MAX. VALUE OF Z FOR SURFACE
C *                                             PLOT
C *                                      XSTEP = STEPSIZE FOR X AND Z
C *   ELSE
C *     READ NRMESH                      NRMESH = # OF R-MESHES
C *     (I5)
C *     DO I=1,NRMESH
C *       READ RSTART,RSTEP,RSTOP        RSTART = 1ST POINT IN ITH MESH
C *       (3F10.5)                       RSTEP  = STEP SIZE IN ITH MESH
C *       END DO                         RSTOP  = LAST POINT IN ITH MESH
C *    END IF
C *  END IF
C *
C *  IF (IBSS .EQ. 0) THEN
C *    READ STO DATA                     SEE ORIGINAL ALAM DOCUMENTATION
C *  ELSE 
C *    READ GTO DATA:
C *    READ TITLE
C *    READ ICON                         THIS SHOULD BE A BLANK CARD
C *    (10I5)
C *    READ NON,NAC *                  THE NEXT FEW READ STATEMENTS
C *    (24I3)                            ARE DOCUMENTED IN POLYINTS.
C *    DO I=1,NON
C *    READ ICNTR(I), (VLIST(I,J), J=1,4)
C *    END DO
C *    READ NGAUS,NCBFN,NOCC             NGAUS = # OF GAUSSIAN PRIMITIVES
C *    (3I3)                             NCBFN = # OF CONTRACTED GTOS
C *                                      NOCC  = # OF OCCUPIED ORBITALS.
C *                                              (N.B. FOR CARTESIAN
C *                                              ORBS, PI(X) AND PI(Y)
C *                                              ARE COUNTED SEPARATELY)
C *    READ GTO INFO                     SEE POLYINTS DOC.
C *    READ (MORB(I), I=1,NOCC           MORB = 0 FOR A SIGMA ORBITAL
C *    (36I2)                                   1 FOR A PI(X) ORBITAL
C *                                             2 FOR A PI(Y) ORBITAL
C *    DO I=1,NOCC
C *    READ ORBITAL TITLE
C *    READ (ORBT(K), K=1,NCBFN          ORBT = LCA0 COEFFS. FOR ITH ORB.
C *    (5D15.8)                                 (FROM POLYSCF OUTPUT)
C *    END DO
C *    IF (IPROJ .NE. 0) THEN
C *      READ LMAX                       LMAX = MAX VALUE OF L FOR THE
C *      (*)                                    ORBITAL EXPANSION
C *      READ (LSTART(I), I=1,NMO(NOCC)) LSTART(I) = MINIMUM VALUE OF L
C *      (*)                                         FOR THE ITH ORBITAL
C *                                      FOR STO ORBS WE USE NMO AS THE
C *                                      NUMBER OF OCCUPIED ORBITALS, BUT
C *                                      FOR GTO ORBS WE USE NOCC.
C *
C *-/

      PI=3.141592653589793D0
      PITERM=2.D0/PI**0.5D0
      PITERN=PI**1.5D0
      XL=ZERO
      XU=PI
      NQUAD=NQANGX
      READ (5,500)  TITLE
      WRITE (6,600) TITLE

C *
C * READ SWITCHES AND OPTIONS
C *
C     READ (5,501) IHETRO,IFDSK,IWRTF,IPNCHA,ISTORA,INDCON,NEWRS,IADSK
C    $     ,IPROJ,IBSS,IPLOT,NPRNT,ITEST
      READ (5,*) IHETRO,IFDSK,IWRTF,IPNCHA,ISTORA,INDCON,NEWRS,IADSK
      READ (5,*) IPROJ,IBSS,IPLOT,NPRNT,ITEST 

      IF (IPLOT .EQ. 1) THEN
         WRITE (2,*) ' ',TITLE
      END IF

      IF (INDCON .EQ. 1) THEN
         WRITE (6,671)
      ELSE IF (INDCON .EQ. 2) THEN
         WRITE (6,670)
      ELSE
         WRITE (6,672)
      END IF
      IF (IHETRO .EQ. 0) THEN
         WRITE (6,601)
         LAMSTP=2
      ELSE
         WRITE (6,602)
         LAMSTP=1
      END IF
      WRITE (6,1009)IFDSK,IWRTF,IPNCHA,ISTORA,IADSK,IPROJ
      IF (ISTORA.EQ.1) REWIND 3
      IF (IWRTF.EQ.1) REWIND 2

C *
C * LAMMIN = MINIMUM LAMBDA FOR ALAM CALC.
C * LAMMAX = MAXIMUM LAMBDA FOR SAME
C *

      IF ((ABS(IPROJ) .NE. 1) .AND. (IPLOT .NE. 1)) THEN
C        READ (5,506) LAMMIN,LAMMAX
         READ (5,*)   LAMMIN,LAMMAX
         NLAM=(LAMMAX - LAMMIN)/LAMSTP + 1
         IF (ITEST .EQ. 1) THEN
            NTEST=NTLAMX
         ELSE
            NTEST=NLAMMX
         END IF
         IF (NLAM .GT. NTEST) THEN
            WRITE (6,*) '  *** TOO MANY LAMDAS: MAX. # =',NTEST,'***'
            STOP
         END IF
         WRITE (6,603) LAMMIN,LAMMAX,LAMSTP
         IF (ITEST .EQ. 1) THEN
            CALL DETANG(XL,XU)
            CALL DETPL
         END IF
      END IF

C *
C * IF WE NEED TO CONSIDER NEW R VALUES, READ THEM AND 
C * THEN READ THE MO DATA.
C *

      IF ((NEWRS .NE. 0) .OR. (IPLOT .EQ. 1)) THEN
         CALL MESH(IPLOT)

C *
C * READ MOLECULAR ORBITAL DATA
C *
         IF (IBSS .EQ. 0) THEN
            CALL RDSTO(IHETRO,INDCON)
         ELSE
            WRITE (6,1007)
            CALL POLY(NPRNT)
            NCT=NON
            NMO=NOCC
            DO I=1,NON
               B(I)=VLIST(I,3)
               Z(I)=VLIST(I,4)
            ENDDO
         END IF
      END IF

C *
C * CHECK TO SEE IF WE NEED ONLY CALCULATE MO EXPANSION COEFF.'S
C *
      IF (ABS(IPROJ) .EQ. 1) THEN
         CALL SPHPRJ(IPROJ)
         STOP
      END IF

C *
C * WE NOW CALCULATE F
C * TIMING STATEMENTS ARE INCLUDED BELOW
C *
      TIME1=0

      CALL FCALC(INDCON,NEWRS,IFDSK,IPLOT,ITEST)

      WRITE (6,612)
      IF (IWRTF .EQ. 0) GO TO 120
C *
C * WRITE CHARGE DENSITY TO DISK WITH NEW POINTS INCLUDED
C *
      WRITE (2,500) TITLE
      WRITE (2,506) NCT,NMO,NRPTS
      DO J = 1,NCT
         WRITE (2,505) J,B(J),Z(J)
      ENDDO
      DO I=1,NQUAD
         WRITE (2,514) ANGLE(I)
         DO J=1,NRPTS
            WRITE (2,513) R(J),F(I,J)
         ENDDO
      ENDDO
 120  CONTINUE

C *
C * IF ITEST=1, THEN
C * CALCULATE X(I,J)=F(I,J)*SIN(THETA)
C *
      IF (ITEST .EQ. 1) THEN
         DO J=1,NQUAD
            THETA = ANGLE(J)
            X = DSIN(THETA)
            DO I=1,NRPTS
               F(J,I) = F(J,I) * X
            ENDDO
         ENDDO

C *
C * IF (ITEST .NE. 1) THEN
C * WE WILL BE USING VALUES OF PLAM(COS(THETA))
C * FROM THE BLOCK DATA TABLE.  THESE VALUES HAVE
C * ALREADY BEEN MULTIPLIED BY SIN(THETA).
C *
      END IF

C *
C * PERFORM PRELIMINARY OUTPUT PRIOR TO CALCULATION OF ALAMDA
C *
      IF (IPNCHA .EQ. 0) GO TO 160
      WRITE (7,702) TITLE
      WRITE (7,703) NCT,LAMMAX
      DO J = 1,NCT
         WRITE (7,704) J,B(J),Z(J)
      ENDDO
 160  IF (ISTORA .EQ. 0) GO TO 190
      WRITE (3,500) TITLE
      WRITE (3,507) NCT,LAMMAX
      DO J = 1,NCT
         WRITE (3,707) Z(J),B(J)
      ENDDO
 190  CONTINUE
      LMAXIN=0
      IF (IADSK .EQ. 0) GO TO 195
      WRITE (6,674)
      READ (8,500) TITLE
      WRITE (6,611) TITLE
      READ (8,507) NCTIN,LMAXIN
      WRITE (6,675) NCTIN,LMAXIN
      DO J=1,NCTIN
         READ (8,707) ZIN,BIN
         WRITE (6,676) ZIN,BIN
      ENDDO

C *
C * CALCULATE THE EXPANSION COEFFICIENTS A-LAMDA
C * TIMING STATEMENTS ARE INCLUDED
C *

 195  CONTINUE
      CALL ALAM(IPNCHA,ISTORA,IADSK,LMAXIN,ITEST)
      WRITE (6,801) TIME1
 801  FORMAT(///' ',15X,'TIME TO CALCULATE ALAMDA = ',F15.5,
     $     ' CPU SECONDS'//)

      IF (IWRTF .EQ. 0) GO TO 200
      REWIND 2
 200  IF (ISTORA .EQ. 0) GO TO 205
      REWIND 3
 205  IF (IPROJ .NE. 0) CALL SPHPRJ(IPROJ)
      STOP

 500  FORMAT(72A1)
 501  FORMAT(36I2)
 505  FORMAT(I5,2F10.5)
 506  FORMAT(3I5,2F10.5)
 507  FORMAT(2I5)
 513  FORMAT(F10.5,D24.16)
C513  FORMAT(F10.5,D23.16)
 514  FORMAT(D24.16)
C514  FORMAT(D23.16)
 600  FORMAT('1',10X,72A1/)
 601  FORMAT(' ',15X,'LINEAR HOMONUCLEAR SYMMETRY'/)
 602  FORMAT(' ',15X,'LINEAR HETERONUCLEAR SYMMETRY'/)
 603  FORMAT(' ',15X,'CALCULATE A-LAMDA FOR LAMDA FROM ',I3,' TO
     $     ',I3, ' IN STEPS OF ',I2///)
 611  FORMAT(' ',10X,72A1/)
 612  FORMAT(/' ',15X,' THE INTEGRAND FACTOR F HAS BEEN CALCULATED'//)
 670  FORMAT(' ',15X,'CONVENTIONS OF CADE ET AL'/)
 671  FORMAT(' ',15X,'CONVENTIONS OF MCLEAN AND YOSHIMINE'/)
 672  FORMAT(' ',15X,'CONVENTIONS OF FRAGA AND RANSIL'/)
 674  FORMAT('1',20X,'PARTIAL ALAMDA FILE ON DISK'/' ',20X,
     $     'INPUT FROM DISK DATA SET'/)
 675  FORMAT(' ',20X,'NUMBER OF CENTERS = ',I5,' MAXIMUM LAMDA = ',I5)
 676  FORMAT(' ',20X,'CHARGE = ',F10.5,5X,'LOCATION = ',F10.5,' BOHR')
 702  FORMAT(' ',72A1)
 703  FORMAT(' ',5X,'NUMBER OF CENTERS = ',I5,5X,'MAXIMUM LAMDA = ',I5)
 704  FORMAT(' ',5X,I5,2(5X,F10.5))
 707  FORMAT(2E15.6)
 1007 FORMAT(/' CARTESIAN GAUSSIAN-TYPE-ORBITAL BASIS SET'/)
 1009 FORMAT(16X,'OTHER OPTIONS:  IFDSK IWRTF IPNCHA ISTORA IADSK',
     $     ' IPROJ'/30X,I5,I6,I7,I7,I6,I6/)

      END

C *-
C *
C * THIS SUBROUTINE CARRIES OUT THE NUMERICAL QUADRATURE OVER ANGLES
C * IT ALSO FITS EACH COEFFICIENT TO AN EXPONENTIAL FORM
C * AND HANDLES THE OUTPUT OF THESE COEFFICIENTS
C *

      SUBROUTINE ALAM(IPNCHA,ISTORA,IADSK,LMAXIN,ITEST)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (LAMMX=40,NTLAMX=21)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      real*8 FR(NRPTSX), FA(NRPTSX), FB(NRPTSX), G(3), SIG(NRPTSX),
     $     FU(NRPTSX,3), FV(3,3), FW(3), CHISQ
      integer NFIT, NDAT
      external FUNCS

      COMMON /NMBRS /  PI, PITERM, PITERN, ICANON
      COMMON /ALAMDA/ A0(NRPTSX),ASM,PSM,QSM,CONT2,RMAX
      COMMON /LAMDAT/ LAMMIN,LAMMAX,LAMSTP,NLAM
      COMMON /ANGSTF/ ANGLE(NQANGX),PLAM(NQANGX,NTLAMX),NQUAD
      COMMON /RDATA/ R(NRPTSX),NRPTS
      COMMON /FCTPS/ JR,JLAM,ITST
      COMMON /WORK/ RIN(NRPTSX),ALAMIN(NRPTSX),XJUNK(31,NRPTSX)

 614  FORMAT('1',20X,'RESULTS FOR LAMDA = ',I5/)
 615  FORMAT(' ',15X,F10.5,5X,D16.8)
 621  FORMAT(///' ',15X,'LAMDA = ',I5,5X,'COEFFICIENT = ',E16.8 /40X
     $     ,'POWER = ',E16.8/37X,'EXPONENT = ',E16.8)
 622  FORMAT(//1X,70('*')/10X
     $     ,'WARNING -- EXTRAPOLATION TO LARGE R MAY BE POOR'/1X,70('*')
     $     /)
 654  FORMAT(' ',21X,'R',13X,'A-LAMDA'/)
 656  FORMAT(///' ',20X,'MOLECULAR CHARGE FROM A0 = ',D16.8)
 658  FORMAT(' ',20X,'CONTRIBUTION FROM RMAX TO INFINITY = ',D16.8)
 659  FORMAT(' ',20X,'TOTAL MOLECULAR CHARGE = ',D16.8//)
 700  FORMAT(' ',5X,'LAMDA = ',I5)
 701  FORMAT(F10.5,3X,D24.16)
C701  FORMAT(F10.5,3X,D23.16)
 708  FORMAT(2I5)
 709  FORMAT(I5,F10.5,D24.16)
C709  FORMAT(I5,F10.5,D23.16)
 710  FORMAT(3D24.16)
C710  FORMAT(3D23.16)

      EXTERNAL FCT

      READ (5,*) NFIT, NDAT
 
      ITST = ITEST
      K = 1
      IF (IADSK .EQ. 0) GO TO 200
      READ (8,708) LAMIN, NRLAM
      DO I = 1,NRLAM
         READ (8,709) LDUM,RIN(I),ALAMIN(I)
      ENDDO
 200  XL = ZERO
      XU = PI
      IFIX = 0
      DO J = 1, NLAM
         LAMDA = LAMMIN + (J - 1)*LAMSTP
         IF (IADSK .EQ. 0) GO TO 205
         IF (LAMDA .EQ. 0) GO TO 205
         IF (LAMDA .GT. LMAXIN) GO TO 205
         READ (8,708) LAMIN, NRLAM
         DO I = 1, NRLAM
            READ (8,709) LDUM, RIN(I), ALAMIN(I)
         ENDDO
 205     CONTINUE
         IF (ITEST .EQ. 1) THEN
            JLAM = J
         ELSE
            JLAM = LAMDA
         END IF
         XLAM = LAMDA
         FACTOR = 0.5D+00 * (XLAM+XLAM+1.0D+00)
         WRITE (6,614) LAMDA
         WRITE (6,654)
         IF (IPNCHA .EQ. 0) GO TO 210
         WRITE (7,700) LAMDA
 210     IF (ISTORA .EQ. 0) GO TO 220
         WRITE (3,708) LAMDA, NRPTS

C *
C * NRPTS = TOTAL NUMBER OF R-VALUES, INCLUDING NEW ONES
C *

 220     DO I = 1,NRPTS
            IF (IADSK .EQ. 0) GO TO 225
            IF (LAMDA .GT. LMAXIN) GO TO 225
            IF (R(I) .LT. RIN(K)) GO TO 225
            IF (DABS(R(I)-RIN(K)) .LE. 1.0D-06) GO TO 223
            GO TO 225
 223        ACALC = ALAMIN(K)
            RNOW = RIN(K)
            K = K + 1
            IF (K .GT. NRLAM) K = 1
            GO TO 224
 225        RNOW = R(I)
            JR = I

C *
C * 9-5-95 WKT      CALL DQG32(XL,XU,FCT,OUTINT)
C * if ifun=0 call FUNCTION FCT
C * if ifun=1 call FUNCTION PROJ
C *
            CALL DQG32(XL,XU,0,OUTINT)

            ACALC = OUTINT * FACTOR
            IF (ACALC .LT. 0.D+00 .AND. RNOW .GT. 0.1D+00) IFIX=1
 224        IF (LAMDA .EQ. 0) A0(I) = ACALC

C *
C * FIT TO EXPONENTIAL FORM AT END FOR EACH LAMDA
C * I ALWAYS LABELS THE CURRENT WORKING R-POINT
C *
            IF (I .GT. NRPTS-NDAT) THEN
               INDEX = NRPTS-I+1
               FR(INDEX) = RNOW
               FA(INDEX) = ACALC
               FB(INDEX) = DLOG(FA(INDEX))
               SIG(INDEX) = 1.0d0
            ENDIF

            IF (I .LT. NRPTS-2) GO TO 230
            IF (I .EQ. NRPTS) GO TO 228
            IF (I .EQ. NRPTS-1) GO TO 226
            R1 = RNOW
            Y1 = ACALC
            GO TO 230
 226        R2 = RNOW
            Y2 = ACALC
            GO TO 230
 228        R3 = RNOW
            Y3 = ACALC
            ABY3=Y3
            ABY2=Y2
            ABY1 = Y1
            IF (Y3 .GT. 0.D+00 .AND. Y2 .GT. Y3 .AND. Y1 .GT. Y2 .AND.
     $           IFIX .EQ. 0) GOTO 229
            IFIX = 1
            ABSY1 = DABS(Y1)
            ABSY2 = DABS(Y2)
            ABSY3 = DABS(Y3)
            ABY3 = DMIN1(ABSY1,ABSY2,ABSY3)
            ABY1 = DMAX1(ABSY1,ABSY2,ABSY3)
            ABY2 = ABSY2
            IF (ABSY1 .NE. ABY1 .AND. ABSY1 .NE. ABY3) ABY2 = ABSY1
            IF (ABSY3 .NE. ABY1 .AND. ABSY3 .NE. ABY3) ABY2 = ABSY3
 229        CONTINUE
            RAT = (R2 - R1)/(R3 - R2)
            IF (NFIT .EQ. 1) THEN
               PSM = (DLOG(ABY2/ABY1)+RAT*DLOG(ABY2/ABY3))/(DLOG(R2/R1)
     $              +RAT*DLOG(R2/R3))
            ELSE IF (NFIT .EQ. 3) THEN
               PSM = 0.0D+00
            ENDIF

            QSM = -DLOG((ABY3/ABY2)*(R2/R3)**PSM)/(R3-R2)
            ASM = Y3*R3**(-PSM)*DEXP(QSM*R3)

 230        WRITE (6,615) RNOW, ACALC
            IF (IPNCHA .EQ. 0) GO TO 235
            WRITE (7,701) RNOW, ACALC
 235        IF (ISTORA .EQ. 0) GO TO 240
            WRITE (3,709) LAMDA, RNOW, ACALC
 240        CONTINUE
         ENDDO

C *
C * LARGE-R FIT BY USING THE LAST N A_LAMBDA (N > 3)
C *
         IF (NFIT .EQ. 2) then
            CALL SVDFIT(FR,FB,SIG,NDAT,G,3,FU,FV,FW,NDAT,3,CHISQ,FUNCS)
            ASM = DEXP(G(1))
            PSM = G(3)
            QSM = -G(2)
         ENDIF

C *
C * OUTPUT FITS OF A LAMDA
C *
         IF (IADSK .EQ. 0) GO TO 245
         IF (LAMDA .GT. LMAXIN) GO TO 245
         READ (8,710) X1, X2, X3
 245     WRITE (6,621) LAMDA, ASM, PSM, QSM
         IF (IFIX.EQ.1) WRITE (6,622)
         IF (IPNCHA .EQ. 0) GO TO 250
         WRITE (7,710) ASM, PSM, QSM
 250     IF (ISTORA .EQ. 0) GO TO 260
         WRITE (3,710) ASM, PSM, QSM
 260     IF (LAMDA .NE. 0) GO TO 300
         CHARGE = CHECKA()
         WRITE (6,656) CHARGE
         WRITE (6,658) CONT2
         CHARGE = CHARGE + CONT2
         WRITE (6,659) CHARGE
 300     CONTINUE
      ENDDO
      RETURN
      END

C *-
C *
C * THIS FUNCTION CALCULATES THE VALUE OF A MOLECULAR ORBITAL
C * AT A GIVEN VALUE OF R AND THETA.
C *
C * FOR STO ORBITALS:
C *    THE MOS ARE ASSUMED TO BE MADE UP OF NUCLEUS-CENTERED
C *    BASIS FUNCTIONS.
C *
C * FOR GTO ORBITALS:
C *    THE MO'S ARE MADE UP OF CONTRACTED GAUSSIANS ON ANY 
C *    CENTER LOCATED IN THE XZ-PLANE.
C *

      DOUBLE PRECISION FUNCTION CALCMO(MOIND,INDCON)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER (SQRT2=1.414213562373095D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /TRGDAT/ R1,R2,R3,THETA1,THETA2,THETA3
      COMMON /MODAT2/ B(NNUCMX),Z(NNUCMX),C(NOCCX,NNUCMX,NSTOMX),
     $     NOCP(NOCCX),NBFN(NOCCX,NNUCMX),NCT,NMO,IPARI(NOCCX)
      COMMON /MOLTYP/ IHETRO
      COMMON /BASIS/ IBSS

      COMMON /LCAOMO/D(NCBFNX,NOCCX)
      COMMON /INDATA1/NTYPE(NCBFNX),NFIRST(NCBFNX),NLAST(NCBFNX)
     $     ,NR(NTMX,3),MORB(NOCCX),NBFXX,NTXX
     $     ,NGXX,NCXX,NON,NCBFN,NOCC
      COMMON /INDATA2/ VLIST(NCMX,4),ETAG(NGMX,5)
      COMMON /PLTMSH/ XMAX,ZMAX,XSTEP,XVAL,ZVAL,NXPTS,NZPTS

      IF (IBSS .EQ. 0) THEN
         SUM = ZERO
         NUCIND = 1
         R = R1
         THETA = THETA1
 10      NFN = NBFN(MOIND,NUCIND)
         DO K=1,NFN
            INDBFN = K
            CHI = BASFN(R,THETA,NUCIND,MOIND,INDBFN)
            TERM = C(MOIND,NUCIND,K) * CHI
            SUM = SUM + TERM
         ENDDO
         IF (NUCIND .EQ. NCT) GO TO 200
         IF (NUCIND .EQ. 1) GO TO 60
C *
C * NCT = 3 AND NUCIND = 2 TO GET TO THIS POINT
C *
         NUCIND = 3
         R = R3
         THETA = THETA3
         GO TO 10
 60      NUCIND = 2
         R = R2
         THETA = THETA2
         GO TO 10
 200     CALCMO = SUM

C *
C * THE CADE ET AL CONVENTION REQUIRES THAT THE MOS BE
C * DIVIDED BY THE SQUARE ROOT OF TWO
C * THIS APPLIES ONLY TO HOMONUCLEAR MOLECULES
C *
         IF (IHETRO .EQ. 1) GO TO 900
         IF (INDCON .EQ. 2) CALCMO = CALCMO / SQRT2
 900     RETURN
      ELSE
C *
C *  CONSTRUCT MO FROM CARTESIAN GTO'S.
C *
C *  ASSUME THAT ALL CENTERS ARE LOCATED IN THE XZ-PLANE, AND
C *  FURTHER, THAT RHO(RVAL,THETA,PHI) WILL BE EVALUATED IN THE
C *  XZ-PLANE AS WELL.  THUS,
C *
C *         AY=ZERO
C *         Y=RVAL*SIN(THETA)*SIN(PHI)=ZERO
C *
         CMO=ZERO
C *
C *  LOOP OVER CONTRACTED GTO'S
C *
         DO I=1,NCBFN
            CGTO=ZERO
            ITYP=NTYPE(I)
            L1=NR(ITYP,1)
            M1=NR(ITYP,2)
C *
C *   IGNORE CONTRIBUTIONS FROM Y-TYPE FCNS.
C *
            IF (M1 .NE. 0) GO TO 2000
            N1=NR(ITYP,3)
            ISTRT=NFIRST(I)
            IFINL=NLAST(I)
            AX=ETAG(ISTRT,1)
            AZ=ETAG(ISTRT,3)
            XDIST=(XVAL - AX)
            ZDIST=(ZVAL - AZ)
            RASQ=XDIST**2 + ZDIST**2
            IF (L1 .EQ. 0) THEN
               XFACTR=ONE
            ELSE
               XFACTR=XDIST**L1
            END IF
            IF (N1 .EQ. 0) THEN
               ZFACTR=ONE
            ELSE
               ZFACTR=ZDIST**N1
            END IF
C *
C *   LOOP OVER PRIMITIVES IN THE CONTRACTION
C *
            DO II=ISTRT,IFINL
               A=ETAG(II,4)
               PGNORM=ETAG(II,5)
               CGTO=CGTO + PGNORM*DEXP(-A*RASQ)
            ENDDO
            CGTO=XFACTR*ZFACTR*CGTO
            CMO=CMO + CGTO*D(I,MOIND)
 2000       CONTINUE
         ENDDO
         CALCMO=CMO
      END IF
      RETURN
      END

C *-
C *
C * THIS SUBROUTINE APPLIES TO HOMONUCLEAR DIATOMIC MOLECULES
C * WHEN STO FUNCTIONS ARE USED.  IT IS NOT USED FOR GTO'S.
C * IT WILL CALCULATE THE EXPANSION COEFFICIENTS FOR THE BASIS
C * FUNCTIONS ON THE RIGHT NUCLEAR CENTER GIVEN THOSE ON THE
C * LEFT CENTER
C *
      SUBROUTINE CCALC(INDCON)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /MODAT1/ ETA(NOCCX,NNUCMX,NSTOMX),N(NOCCX,NNUCMX,NSTOMX)
     $     ,L(NOCCX,NNUCMX,NSTOMX),M(NOCCX,NNUCMX,NSTOMX)
      COMMON /MODAT2/ B(NNUCMX),Z(NNUCMX),C(NOCCX,NNUCMX,NSTOMX),
     $     NOCP(NOCCX),NBFN(NOCCX,NNUCMX),NCT,NMO,IPARI(NOCCX)
      COMMON /LT3/ DIJ(NOCCX,NNUCMX,NSTOMX),NCON(NOCCX,NNUCMX,NSTOMX)
     $     ,MP(NOCCX,NNUCMX,NSTOMX)
      COMMON /BASIS/ IBSS

 600  FORMAT('1',20X,' CALCULATE COEFFICIENTS FOR CENTER ',I2/)
 601  FORMAT(' ',15X,'NUMBER OF BASIS FUNCTIONS = ',I5,5X, ' B = ',F10.5
     $     ,' BOHR'//)
 602  FORMAT(///' ',15X,'ORBITAL NUMBER ',I5/)
 604  FORMAT(' ',20X,3(I3,2X),F10.5,5X,F10.5)
 605  FORMAT(' ',22X,'N',4X,'L',4X,'M',7X,'C',15X,'ETA')

      NCENT = NCT + 1
      WRITE (6,600) NCENT
      B(NCENT) = -B(1)
      Z(NCENT) = Z(1)
      DO I = 1,NMO
         WRITE (6,602) I
         NBFN(I,NCENT) = NBFN(I,1)
         WRITE (6,601) NBFN(I,NCENT),B(NCENT)
         WRITE (6,605)
         KUPR = NBFN(I,1)
         DO K=1,KUPR
            N(I,NCENT,K) = N(I,1,K)
            L(I,NCENT,K) = L(I,1,K)
            M(I,NCENT,K) = M(I,1,K)
            ETA(I,NCENT,K) = ETA(I,1,K)
C *
C * HERE WE TAKE ACCOUNT OF THE DIFFERENT DEFINING
C * CONVENTIONS - SEE ASSOCIATED DOCUMENTATION FOR DETAILS
C *
            IPWR = L(I,1,K)
            IF (INDCON .NE. 1) IPWR = M(I,1,K)
            FCTR = ONE
            IF (MOD(IPWR,2) .NE. 0) FCTR = -ONE
            FCTR = FCTR * IPARI(I)
            C(I,NCENT,K) = C(I,1,K) * FCTR
            WRITE (6,604) N(I,NCENT,K),L(I,NCENT,K),M(I,NCENT,K), C(I
     $           ,NCENT,K),ETA(I,NCENT,K)
         ENDDO
      ENDDO
      NCT = NCENT
      RETURN
      END

C *-
C *
C * THIS CODE CALCULATES LEGENDRE POLYNOMIALS (UNNORMALIZED) AT
C * THE ANGLES WHICH ARE REQUIRED FOR THE DESIRED QUADRATURE
C *
      SUBROUTINE DETPL
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (LAMMX=40,NTLAMX=21)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /ANGSTF/ ANGLE(NQANGX),PLAM(NQANGX,NTLAMX),NQUAD
      COMMON /LAMDAT/ LAMMIN,LAMMAX,LAMSTP,NLAM

      DO J = 1,NLAM
         LAMDA = (J-1) * LAMSTP + LAMMIN
         DO I = 1,NQUAD
            THETA = ANGLE(I)
            PLAM(I,J) = PML(LAMDA,0,THETA)
         ENDDO
      ENDDO
      RETURN
      END

C *-
C *
C * THIS SUBROUTINE CALCULATES THE PROBABILITY DENSITY OF THE
C * MOLECULE AS A FUNCTION OF R AND THETA
C * THESE VALUES WILL BE REFERRED TO THE NUCLEAR CENTERS
C * THE PRESENT VERSION INTERPOLATES NEW R-VALUES WITH THOSE FOR
C * WHICH F HAS ALREADY BEEN CALCULATED
C * AT END R WILL CONTAIN THE FINAL R-MESH
C *
C *
C *                 >>>> IPLOT .EQ. 1 OPTION <<<<
C *
C * THIS SUBROUTINE HAS BEEN MODIFIED TO PROVIDE THE PROBABILITY
C * DENSITY OF THE TARGET ON A CARTESIAN MESH X,Z FOR THE PUR-
C * POSE OF MAKING SURFACE PLOTS.  THE XZ-PLANE IS ALWAYS
C * ASSUMED.
C *
      SUBROUTINE FCALC(INDCON,NEWRS,IFDSK,IPLOT,ITEST)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (LAMMX=40,NTLAMX=21)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /ANGSTF/ ANGLE(NQANGX),PLAM(NQANGX,NTLAMX),NQUAD
      COMMON /RDATA/ R(NRPTSX),NRPTS
      COMMON /RINP/ RMESH(NRPTSX),NRIN
      COMMON /FMAT/ F(NQANGX,NRPTSX)
      COMMON /MODAT2/ B(NNUCMX),Z(NNUCMX),C(NOCCX,NNUCMX,NSTOMX),
     $     NOCP(NOCCX),NBFN(NOCCX,NNUCMX),NCT,NMO,IPARI(NOCCX)
      COMMON /WORK/ RIN(NRPTSX),FIN(NQANGX,NRPTSX)
      COMMON /INDATA1/NTYPE(NCBFNX),NFIRST(NCBFNX),NLAST(NCBFNX)
     $     ,NR(NTMX,3),MORB(NOCCX),NBFXX,NTXX
     $     ,NGXX,NCXX,NON,NCBFN,NOCC
      COMMON /INDATA2/ VLIST(NCMX,4),ETAG(NGMX,5)
      COMMON /PLTMSH/ XMAX,ZMAX,XSTEP,XVAL,ZVAL,NXPTS,NZPTS
      COMMON /BASIS/ IBSS

      CHARACTER TITLE(72)

      IF (IFDSK .EQ. 0) GO TO 40
      WRITE (6,600)
      READ (4,200) TITLE
      WRITE (6,601) TITLE
      READ (4,201) NCTIN,NMOIN,NRPTIN
      WRITE (6,602) NCTIN
      WRITE (6,603) NMOIN
      DO J = 1,NCTIN
         READ (4,202) JIN,BIN,ZIN
         WRITE (6,604) JIN,BIN,ZIN
         IF (NEWRS .NE. 0)GO TO 10
         B(J)=BIN
         Z(J)=ZIN
 10      CONTINUE
      ENDDO
      IF (NEWRS .NE. 0) GO TO 15
      NCT=NCTIN
      NMO=NMOIN
 15   CONTINUE
      READ (4,204) AIN
      DO J = 1,NRPTIN
         READ (4,203) RIN(J),FIN(1,J)
      ENDDO
      DO I = 2,NQUAD
         READ (4,204) AIN
         DO J = 1,NRPTIN
            READ (4,203) RTEMP,FIN(I,J)
         ENDDO
      ENDDO

C *
C * SUPPLEMENT F WITH NEW POINTS
C *
      IF (NEWRS .EQ. 0) GO TO 196

C *
C * IF NO R VALUES ARE ON DISK, MUST CALCULATE F AT ALL
C * R IN RMESH
C *
 40   INDIC = 0
      L = 1
      I = 1
      IF (IFDSK .EQ. 0) GO TO 105
      J = 1
 100  IF (RIN(J) .LT. RMESH(I)) GO TO 150
      IF (DABS(RIN(J)-RMESH(I)) .LE. 1.0E-06) GO TO 140
 105  CONTINUE

C *
C *     >>>> IPLOT .EQ. 1 <<<<
C *
      IF (IPLOT .EQ. 1) THEN
         WRITE (6,*) '  ### CALCULATE RHO FOR SURFACE PLOT ###'
         NXZPTS=NXPTS*NZPTS
         WRITE (2,*) ' ',NXZPTS
         ZVAL= -ZMAX
         DO INDXZ=1,NZPTS
            XVAL= -XMAX
            DO INDXX=1,NXPTS
               RHOXZ=ZERO
               IF (IBSS .EQ. 0) THEN
                  RVAL=DSQRT(XVAL**2 + ZVAL**2)
                  IF (RVAL .LT. 1.0D-06) THEN
                     THETA=ZERO
                  ELSE
                     THETA=DACOS(ZVAL/RVAL)
                  END IF
                  CALL TRIGFN(RVAL,THETA,INDCON,1,ITEST)
                  DO MOIND=1,NMO
                     CONMO=CALCMO(MOIND,INDCON)
                     RHOXZ=RHOXZ + NOCP(MOIND)*CONMO**2
                  ENDDO
               ELSE
                  DO MOIND=1,NOCC

C *
C * IN THE XZ-PLANE, PI-Y ORBITALS MAKE NO CONTRIBUTION.
C * SEE THE NOTES ON MODIFICATIONS TO ALAM.
C *
                     IF (MORB(MOIND) .NE. 2) THEN
                        CONMO=CALCMO(MOIND,INDCON)
                        RHOXZ=RHOXZ + CONMO**2
                     END IF
                  ENDDO

C *
C * THE OCCUPATION NUMBER FOR CARTESIAN MO'S FROM A CLOSED-
C * SHELL TARGET IS ALWAYS TWO.
C *
                  RHOXZ=TWO*RHOXZ
               END IF
               WRITE (2,606) XVAL,ZVAL,RHOXZ
               XVAL=XVAL + XSTEP
            ENDDO
            ZVAL=ZVAL + XSTEP
         ENDDO
         STOP
      END IF

C *
C * CALCULATE F=RHO AT THE NEW POINT RMESH(I)
C *
      R(L) = RMESH(I)
      RVAL = R(L)
      DO K = 1,NQUAD
         THETA = ANGLE(K)
         RHO=ZERO
         CALL TRIGFN(RVAL,THETA,INDCON,K,ITEST)
         IF (IBSS .EQ. 0) THEN
            DO MOIND=1,NMO
               CONMO=CALCMO(MOIND,INDCON)
               RHO=RHO + NOCP(MOIND)* CONMO**2
            ENDDO
         ELSE
            DO MOIND=1,NOCC

C *
C * IN THE XZ-PLANE, PI-Y ORBITALS MAKE NO CONTRIBUTION.
C * SEE THE NOTES ON MODIFICATIONS TO ALAM.
C *
               IF (MORB(MOIND) .NE. 2) THEN
                  CONMO=CALCMO(MOIND,INDCON)
                  RHO=RHO + CONMO**2
               END IF
            ENDDO

C *
C * THE OCCUPATION NUMBER FOR CARTESIAN MO'S FROM A CLOSED-
C * SHELL TARGET IS ALWAYS TWO.
C *
            RHO=TWO*RHO
         END IF
         F(K,L)=RHO
      ENDDO
      IF (IFDSK .NE. 0) GO TO 125

C *
C * IF NO POINTS WERE READ FROM DISK, WE ARE JUST CALCULATING
C * NEW F VALUES
C *
      I = I + 1
      IF (I .GT. NRIN) GO TO 190
      L = L + 1
      GO TO 105

 125  I = I + 1
      IF (I .LE. NRIN) GO TO 180
      IF (INDIC .EQ. 3) GO TO 190
      INDIC = 1

C *
C * INDIC = 1 IF WE HAVE PROCESSED ALL THE NEW R POINTS IN RMESH
C *
      L = L + 1
      GO TO 150
 140  CONTINUE
      I = I + 1
      IF (I .GT. NRIN) INDIC = 1
 150  CONTINUE
      DO K = 1,NQUAD
         F(K,L) = FIN(K,J)
      ENDDO
      R(L) = RIN(J)
      J = J + 1
      IF (J .LE. NRPTIN) GO TO 180
      IF (I .GT. NRIN) GO TO 190
      INDIC = 3

C *
C * INDIC = 3 IF WE HAVE PROCESSED ALL THE OLD R POINTS IN RIN
C *
 180  L = L + 1
      IF (INDIC .EQ. 1) GO TO 150
      IF (INDIC .EQ. 3) GO TO 105
      GO TO 100
 190  NRPTS = L
 195  WRITE (6,605) NRPTS
      RETURN

C *
C * TRANSFER FIN TO F AND RIN TO R
C *

 196  CONTINUE
      L = 1
      DO J = 1,NRPTIN
         R(J) = RIN(J)
         DO K = 1,NQUAD
            F(K,J) = FIN(K,J)
         ENDDO
      ENDDO
      NRPTS = NRPTIN
      GO TO 195

 200  FORMAT(72A1)
 201  FORMAT(3I5)
 202  FORMAT(I5,2F10.5)
C203  FORMAT(F10.5,D24.16)
 203  FORMAT(F10.5,D23.16)
C204  FORMAT(D24.16)
 204  FORMAT(D23.16)
 600  FORMAT(///' ',15X,'PARTIAL CHARGE DENSITY TO BE READ FROM DIS
     $     K' /' ',15X,'INPUT FROM DISK DATA SET'///)
 601  FORMAT(' ',15X,72A1)
 602  FORMAT(' ',20X,'NUMBER OF CENTERS = ',I5)
 603  FORMAT(' ',20X,'NUMBER OF MOLECULAR ORBITALS = ',I5)
 604  FORMAT(' ',20X,'CENTER ',I5,' AT ',F10.5,' BOHR WITH Z = ',F6.2)
 605  FORMAT(/////' ',20X,'TOTAL NUMBER OF R-VALUES = ',I5//)
 606  FORMAT(' ',F10.5,1X,F10.5,1X,1PD15.8)

      END

C *-
C *
C * THIS CODE CALCULATES THE INTEGRAND FOR THE NUMERICAL QUADRATURE
C * OF THE FUNCTION F AT A GIVEN ANGLE THETA IN RADIANS
C *

      DOUBLE PRECISION FUNCTION FCT(THETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12,NLAMMX=41)
      PARAMETER (LAMMX=40,NTLAMX=21)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /FMAT/ F(NQANGX,NRPTSX)
      COMMON /ANGSTF/ ANGLE(NQANGX),PLAM(NQANGX,NTLAMX),NQUAD
      COMMON /FCTPS/ JR,JLAM,ITEST

      COMMON /PRMANG/ QANG(NQANGX),SN(NQANGX),CS(NQANGX),PLSNQA(NQANGX
     $     ,0:LAMMX)

 800  FORMAT(///' ',30X,'UNABLE TO FIND THETA = ',D16.8,' IN FCT'/)

C *
C * JR IS A SUBSCRIPT FOR F ASSOCIATED WITH A GIVEN R VALUE
C * JLAM IS A SUBSCRIPT FOR PLAM ASSOCIATED WITH LAMDA
C *
C * WE NOW DETERMINE THE ANGLE SUBSCRIPT FOR PLAM
C *
C * IF (ITEST .NE. 1) THEN
C * JLAM=LAMDA AND
C * WE MULTIPLY THE CHARGE DENSITY BY PLSNQA(ITHET,LAMDA)
C * FROM THE BLOCK DATA TABLE.  THIS QUANTITY HAS ALREADY
C * BEEN MULTIPLIED BY SIN(THETA).
C *
      DO I = 1,NQUAD
         ISUB = I
         X = DABS(THETA - ANGLE(I))
         IF (X .LE. 1.0E-06) GO TO 20
      ENDDO
      WRITE (6,800) THETA
      STOP
 20   CONTINUE
      IF (ITEST .EQ. 1) THEN
         FCT = PLAM(ISUB,JLAM) * F(ISUB,JR)
      ELSE
         FCT = PLSNQA(ISUB,JLAM) * F(ISUB,JR)
      END IF
      RETURN
      END

C *-
C *
C * THIS CODE CALCULATES A NORMALIZED SLATER TYPE ORBITAL
C * FOR GIVEN R AND THETA DEFINED WITH RESPECT TO CENTER NUCIND
C * THE PARTICULAR STO PARAMETERS ARE IDENTIFIED BY THE
C * BASIS FUNCTION INDICATOR INDBFN AND THE MO INDICATOR MOIND
C *

      DOUBLE PRECISION FUNCTION BASFN(R,THETA,NUCIND,MOIND,INDBFN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /MODAT1/ ETA(NOCCX,NNUCMX,NSTOMX),N(NOCCX,NNUCMX,NSTOMX)
     $     ,L(NOCCX,NNUCMX,NSTOMX),M(NOCCX,NNUCMX,NSTOMX)

      NT = N(MOIND,NUCIND,INDBFN)
      LT = L(MOIND,NUCIND,INDBFN)
      MT = M(MOIND,NUCIND,INDBFN)
      ETAT = ETA(MOIND,NUCIND,INDBFN)
      X = PML(LT,MT,THETA)
      X = X * XNR(LT,MT)
      X = X * DEXP(-ETAT*R)
      RPN = ONE
      NPWR = NT - 1
      IF (NPWR .EQ. 0) GO TO 20
      DO I = 1,NPWR
         RPN = RPN * R
      ENDDO
 20   X = X * RPN

C *
C * CALCULATE NORMALIZATION FACTOR
C *
      TWETA = TWO * ETAT
      NNPO = NT + NT + 1
      XNUM = TWETA
      DO I = 2,NNPO
         XNUM = XNUM * TWETA
      ENDDO
      NN = NNPO - 1
      DEN = FACX(NN)
      STONRM = DSQRT(XNUM/DEN)
      BASFN = X * STONRM
      RETURN
      END

C *-
C *
C * THIS ROUTINE CONVERTS R AND THETA, SPHERICAL COORDINATES
C * DEFINED WITH RESPECT TO THE CENTER-OF-MASS OF THE MOLECULE
C * TO COORDINATES CENTERED ON THE NUCLEAR CENTERS
C *

      SUBROUTINE TRIGFN(R,THETA,INDCON,ITHET,ITEST)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (LAMMX=40)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /MODAT2/ B(NNUCMX),Z(NNUCMX),C(NOCCX,NNUCMX,NSTOMX),
     $     NOCP(NOCCX),NBFN(NOCCX,NNUCMX),NCT,NMO,IPARI(NOCCX)
      COMMON /TRGDAT/ R1,R2,R3,THETA1,THETA2,THETA3
      COMMON /BASIS/ IBSS

      COMMON /PLTMSH/ XMAX,ZMAX,XSTEP,XVAL,ZVAL,NXPTS,NZPTS
      COMMON /PRMANG/ QANG(NQANGX),SN(NQANGX),CS(NQANGX),PLSNQA(NQANGX
     $     ,0:LAMMX)

      IF ((IBSS .EQ. 1) .AND. (ITEST .NE. 1)) THEN
         XVAL=R*SN(ITHET)
         ZVAL=R*CS(ITHET)
         RETURN
      ELSE IF (IBSS .EQ. 1) THEN
         XVAL=R*DSIN(THETA)
         ZVAL=R*DCOS(THETA)
         RETURN
      END IF
      RSQ = R * R
      COSTH = DCOS(THETA)
      J = 1
 10   BJ = B(J)
      BSQ = BJ * BJ
      IF (J .EQ. 1) GO TO 20
      IF (J .EQ. NCT) GO TO 20

C *
C * J = 2 AND NCT = 3 TO GET TO THIS POINT
C *
      IF (DABS(BJ) .LE. 1.0D-06) GO TO 15
      GO TO 20

C *
C * CENTER 2 IS THE COORDINATE ORIGIN TO GET TO HERE (HOMONUCLEAR)
C *
 15   RJ = R
      THJ = THETA
      GO TO 60
 20   RJSQ = RSQ + BSQ - 2.0D+00*R*BJ*COSTH
      RJ = DSQRT(RJSQ)
      COSTHJ = 1.0D+00
      IF (RJ .GE. 1.0D-06) COSTHJ = 0.5D+00*(RSQ-RJSQ-BSQ)/(RJ*BJ)

C *
C * IF WE ARE USING CONVENTIONS OTHER THAN MCLEAN AND YOSHIMINE
C * WE MUST CHANGE THE HANDED-NESS OF THE COORDINATE SYSTEMS
C * THIS IS DONE BY REPLACING THETA WITH PI - THETA
C *
      IF (INDCON .NE. 1  .AND.  J .EQ. NCT) COSTHJ = -COSTHJ
      THJ = DACOS(COSTHJ)
      IF (J .NE. 1) GO TO 50
      R1 = RJ
      THETA1 = THJ
      J = 2
      GO TO 10
 50   IF (J .NE. 2) GO TO 70
 60   R2 = RJ
      THETA2 = THJ
      IF (NCT .EQ. 2) GO TO 900
      J = 3
      GO TO 10
 70   R3 = RJ
      THETA3 = THJ
 900  RETURN
      END

C *-
C *
C * THIS SUBROUTINE DETERMINES THE ANGLES NEEDED FOR A 32 POINT GAUSS
C * LEGENDRE QUADRATURE
C *

      SUBROUTINE DETANG(XL,XU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (LAMMX=40,NTLAMX=21)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /ANGSTF/ ANGLE(NQANGX),PLAM(NQANGX,NTLAMX),NQUAD

      A = .5D+00 * (XU+XL)
      B = XU-XL
      C = .4986319309247408D+00 * B
      ANGLE(1) = A+C
      ANGLE(2) = A-C
      C = .4928057557726342D+00 * B
      ANGLE(3) = A+C
      ANGLE(4) = A-C
      C = .4823811277937532D+00 * B
      ANGLE(5) = A+C
      ANGLE(6) = A-C
      C = .4674530379688698D+00 * B
      ANGLE(7) = A+C
      ANGLE(8) = A-C
      C = .4481605778830261D+00 * B
      ANGLE(9) = A+C
      ANGLE(10) = A-C
      C = .4246838068662850D+00 * B
      ANGLE(11) = A+C
      ANGLE(12) = A-C
      C = .3972418979839712D+00 * B
      ANGLE(13) = A+C
      ANGLE(14) = A-C
      C = .3660910593701448D+00 * B
      ANGLE(15) = A+C
      ANGLE(16) = A-C
      C = .3315221334651076D+00 * B
      ANGLE(17) = A+C
      ANGLE(18) = A-C
      C = .2938578786203812D+00 * B
      ANGLE(19) = A+C
      ANGLE(20) = A-C
      C = .2534499544661147D+00 * B
      ANGLE(21) = A+C
      ANGLE(22) = A-C
      C = .2106756380653177D+00 * B
      ANGLE(23) = A+C
      ANGLE(24) = A-C
      C = .1659343011410638D+00 * B
      ANGLE(25) = A+C
      ANGLE(26) = A-C
      C = .1196436811260685D+00 * B
      ANGLE(27) = A+C
      ANGLE(28) = A-C
      C = .7223598079139825D-01*B
      ANGLE(29) = A+C
      ANGLE(30) = A-C
      C = .2415383284386916D-01*B
      ANGLE(31) = A+C
      ANGLE(32) = A-C
      RETURN
      END

C *-
C *
C * THIS IS A FACTORIAL FUNCTION
C *

      DOUBLE PRECISION FUNCTION FACX(I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION TABLE(15)
      DATA TABLE/1.D0,2.D0,6.D0,24.D0,120.D0,720.D0,5040.D0,40320.D0,
     $     362880.D0,36288.D+02,399168.D+02,4790016.D+02,62270208.D+02,
     $     871782912.D+02,1307674368.D+03/
      FACX = 1.0D+00
      IF (I.LT.0) GOTO 95
      IF (I.EQ.0) GOTO 100
      IF (I.GT.15) GOTO 30
      FACX = TABLE(I)
      GO TO 200
 30   FJ = 16.0D+00
      FACX = TABLE(15)
      DO J = 16,I
         FACX = FACX * FJ
         FJ = FJ + 1.0D+00
      ENDDO
      GO TO 200
 95   FACX = 0.0D+00
 100  CONTINUE
 200  RETURN
      END

C *-
C *
C * THIS SUBFUNCTION CALCULATES ASSOCIATED LEGENDRE POLYNOMIALS OF
C * ANY ORDER P SUB LX SUPER MX OF XF
C * THE ARGUMENT XF MUST BE THE ANGLE IN RADIANS
C * THE CODE USES EXPLICIT FORMULAS FOR L THROUGH 8
C * NOTE THAT FOR L GREATER THAN 4 ONLY M = 0,1,AND 2 ARE
C * INCLUDED
C * THE RECURRENCE FORMULAS APPLY ONLY TO M = 0,1, AND 2
C * THE CONVENTIONS OF MCLEAN AND YOSHIMINE ARE USED FOR SIGNS
C *

      DOUBLE PRECISION FUNCTION PML(LX,MX,XF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      X= DCOS(XF)
      XP = DSIN(XF)
      X2 = X * X
      X3 = X2 * X
      X4 = X3 * X
      XP2 = XP * XP
      XP3 = XP2 * XP
      XP4 = XP3 * XP
      K = LX+1
      M = MX+1

C * SPECIAL CASES FOR SMALL ARGUMENTS
      IF (DABS(X-1.0D+00) .LE. 1.0D-06)  GO TO 215
C *
C * K = ORDER OF POLYNOMIAL + 1
C * IF ORDER GREATER THAN 8 USE STANDARD RECURRENCE RELATION
      IF (K .GT. 9) GO TO 110

      IF (K .EQ. 9) GO TO 100
      IF (K .EQ. 8) GO TO 90
      IF (K .EQ. 7) GO TO 80
      IF (K .EQ. 6) GO TO 70
      IF (K .EQ. 5) GO TO 50
      IF (K .EQ. 4) GO TO 40
      IF (K .EQ. 3) GO TO 30
      IF (K .EQ. 2) GO TO 20

      PML = 1.0D+00
      GO TO 60
 20   IF (M .EQ. 2) GO TO 22
      PML = X
      GO TO 60
 22   PML = XP
      GO TO 60
 30   IF (M .EQ. 3) GO TO 33
      IF (M .EQ. 2) GO TO 32
      PML = 1.5D0*X2-0.5D0
      GO TO 60
 32   PML = 3.0D+00 * X * XP
      GO TO 60
 33   PML = 3.0D+00 * XP2
      GO TO 60
 40   IF (M .EQ. 4) GO TO 44
      IF (M .EQ. 3) GO TO 43
      IF (M .EQ. 2) GO TO 42
      PML = 2.5D0 * X3-1.5D0 * X
      GO TO 60
 42   PML = XP * (7.5D+00 * X2-1.5D+00)
      GO TO 60
 43   PML = 15.0D+00 * XP2 * X
      GO TO 60
 44   PML = 15.0D+00 * XP3
      GO TO 60
 50   IF (M .EQ. 5) GO TO 55
      IF (M .EQ. 4) GO TO 54
      IF (M .EQ. 3) GO TO 53
      IF (M .EQ. 2) GO TO 52
      PML = (35.0D0*X4-30.D0*X2+3.0D0)/8.0D0
      GO TO 60
 52   PML = XP * (35.0D+00 * X3-15.0D+00 * X)/2.0D+00
      GO TO 60
 53   PML = XP2 * (105.0D+00 * X2-15.0D+00)/2.0D+00
      GO TO 60
 54   PML = 105.0D+00 * XP3 * X
      GO TO 60
 55   PML=105.0D+00 * XP4
 70   IF (M .EQ. 3) GO TO 73
      IF (M .EQ. 2) GO TO 72
      PML=(63.D0*X4*X-70.D0*X3+15.D0*X)/8.D0
      GO TO 60
 72   PML=XP*(315.D0*X4-210.D0*X2+15.D0)/8.D0
      GO TO 60
 73   PML = (105.0D+00 * XP2 * (3.0D+00 * X2-1.0D+00) * X)/2.0D+00
      GO TO 60
 80   IF (M .EQ. 3) GO TO 83
      IF (M .EQ. 2) GO TO 82
      PML=(231.D0*X2*X4-315.D0*X4+105.D0*X2-5.0D0)/16.D0
      GO TO 60
 82   PML=X*XP*(693.D0*X4-630.D0*X2+105.D0)/8.D0
      GO TO 60
 83   PML=(105.0D+00*XP2*(33.0D+00*X4-18.0D+00*X2+1.0D+00))/8.0D+00
      GO TO 60
 90   IF (M .EQ. 3) GO TO 93
      IF (M .EQ. 2) GO TO 92
      PML=(429.D0*X4*X3-693.0D0*X4*X+315.0D0*X3-35.0D0*X)/16.D0
      GO TO 60
 92   PML=XP*((3003.D0*X4-3465.D0*X2+945.D0)*X2-35.D0)/16.D0
      GO TO 60
 93   PML=63.D0*(143.D0*X4-110.D0*X2+15.D0)*X*(XP2/8.D0)
      GO TO 60
 100  IF (M .EQ. 3) GO TO 103
      IF (M .EQ. 2) GO TO 102
      PML=(6435.D0*X4*X4-12012.D0*X4*X2+6930.D0*X4-1260.D0*X2+35.D0)
     $     /128.D0
      GO TO 60
 102  PML=X*XP*((6435.D0*X4-9009.D0*X2+3465.D0)*X2-315.D0)/16.D0
      GO TO 60
 103  PML=630.D0*(143.D0*X4*(X2-1.D0)+33.D0*X2-1.0D0)*(XP2/32.D0)
      GO TO 60
 110  LTEMP=8

C * SET PML EQUAL TO PM8 AND PMO EQUAL TO PM7 INITIALLY

      IF (M .EQ. 3) GO TO 202
      IF (M .EQ. 2) GO TO 201
      PML=(6435.D0*X4*X4-12012.D0*X4*X2+6930.D0*X4-1260.D0*X2+35.D0)
     $     /128.D0
      PMO=(429.D0*X4*X3-693.0D0*X4*X+315.0D0*X3-35.0D0*X)/16.D0
      GO TO 210
 201  PML=X*XP*((6435.D0*X4-9009.D0*X2+3465.D0)*X2-315.D0)/16.D0
      PMO=XP*((3003.D0*X4-3465.D0*X2+945.D0)*X2-35.D0)/16.D0
      GO TO 210
 202  PML=XP2*630.D0*(143.D0*X4*(X2-1.D0)+33.D0*X2-1.D0)/32.D0
      PMO=XP2*63.D0*(143.D0*X4-110.D0*X2+15.D0)*X/8.D0
 210  FACTR1=FLOAT(2*LTEMP+1)/FLOAT(LTEMP-MX+1)
      FACTR2=FLOAT(LTEMP+MX)/FLOAT(LTEMP-MX+1)

C * PMLNEW EQUALS P OF ORDER LTEMP+1
      PMLNEW=FACTR1*X *PML-FACTR2*PMO
      PMO=PML
      PML=PMLNEW
      LTEMP=LTEMP+1
      IF (LTEMP.EQ.LX) GO TO 60
      GO TO 210
 215  PML=1.0D+00
      IF (MX .NE. 0) PML=0.0D+00
 60   CONTINUE
      RETURN
      END

C *-
C *
C * THIS FUNCTION DEFINES A SCALING CONSTANT NEEDED TO EVALUATE THE
C * NORMALIZED ASSOCIATED LEGENDRE POLYNOMIALS
C *
C * MODIFIED 3/17/81 TO CALCULATE YLM(THETA,PHI=0); MEL CONVENTIONS
C *
C * SEE MEL  EQUATION (2.55)
C *

C 9-4-95 WKT      DOUBLE PRECISION FUNCTION XNR(L,M,THETA)
      DOUBLE PRECISION FUNCTION XNR(L,M)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (FOURPI = 12.56637062D+00)
      MABS = IABS(M)
      LPM = L + MABS
      LMM = L - MABS
      IF (LMM .LT. 0) GO TO 30
      XL = L
      X = (XL + XL + ONE) / FOURPI
      FACTR=ONE
      ILPM=LPM
 10   IF (ILPM .EQ. LMM) GO TO 20
      FACTR=FACTR*FLOAT(ILPM)
      ILPM=ILPM-1
      GO TO 10
 20   X=X/FACTR

C *
C *  THE FOLLOWING STATEMENTS OBEY THE CONDON AND SHORTLEY
C *  PHASE CONVENTION.  HOWEVER, ALAM ACCOUNTS FOR THE PHASE
C *  CONVENTION IN OTHER ROUTINES--SO THESE STATEMENTS HAVE
C *  BEEN COMMENTED OUT.
C *
C *  SIGN=ONE
C *  MSIGN=(M+MABS)/2
C *  SIGN=(-SIGN)**MSIGN
C *  XNR = DSQRT(X)*SIGN
C *
      XNR = DSQRT(X)
      RETURN
 30   XNR=ZERO
      RETURN
      END

C *-
C *
C * THIS CODE CALCULATES THE TOTAL CHARGE ON THE MOLECULE
C * FROM A-LAMDA FOR LAMDA = 0 USING A TRAPEZOIDAL RULE
C *

      FUNCTION CHECKA()
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12,NPTSMX=121)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /ALAMDA/ A0(NRPTSX),ASM,PSM,QSM,CONT2,RMAX
      COMMON /RDATA/ R(NRPTSX),NRPTS

      SUMINT = ZERO
      K = 1
      HNOW = R(2) - R(1)
      RR = R(1) * R(1)

C *
C * THE INTEGRAND IS ZERO FOR THE FIRST POINT SO WE START
C * AT R(1) WITH QUADRATURE WEIGHT = STEP SIZE
C *
      SUM = A0(1) * RR
      GO TO 20
 10   SUM = 0.5D+00 * A0(K) * RR
 20   K = K + 1
      RNOW = R(K)
      RR = RNOW * RNOW
      IF (K .EQ. NRPTS) GO TO 30
      HTEST = R(K+1) - R(K)
      IF (DABS(HTEST - HNOW) .LE. 1.0E-06) GO TO 60
 30   SUM = (SUM + 0.5D+00 * A0(K) * RR) * HNOW
      SUMINT = SUMINT + SUM
      IF (K .EQ. NRPTS) GO TO 100
      HNOW = HTEST
      GO TO 10
 60   SUM = SUM + A0(K) * RR
      GO TO 20
 100  CHECKA = SUMINT * 12.56637062D+00

C *
C * CALCULATE CONTRIBUTION TO TOTAL MOLECULAR CHARGE FROM
C * RMAX (LAST R FOR WHICH WE HAVE A0) TO INFINITY
C *
      RMAX = R(NRPTS)
      CALL DQL16(F6)
      CONT2 = 12.56637062D+00*(ASM/QSM)*DEXP(-QSM*RMAX)*F6

      RETURN
      END

C *-
      DOUBLE PRECISION FUNCTION FCTA(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (NRPTSX=700)
      COMMON /ALAMDA/ A0(NRPTSX),ASM,PSM,QSM,CONT2,RMAX
      FCTA=(X/QSM+RMAX)**(PSM+2.0D+00)
      RETURN
      END

C *-
C *
C *
C * SUBROUTINE TO INTEGRATE EXPONENTIAL ALAM FROM RMAX TO INFINITY
C *
C *
      SUBROUTINE DQL16(Y)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /ALAMDA/ A0(NRPTSX),ASM,PSM,QSM,CONT2,RMAX

      X=.51701160339543318D+02
      Y=.41614623703728552D-21 * FCTA(X)
      X=.41940452647688333D+02
      Y=Y+.50504737000355128D-17 * FCTA(X)
      X=.34583398702286626D2
      Y=Y+.62979670025178678D-14 * FCTA(X)
      X = .28578729742882140D2
      Y = Y + .21270790332241030D-11 * FCTA(X)
      X = .23515905693991909D2
      Y = Y + .28623502429738816D-9 * FCTA(X)
      X = .19180156856753135D2
      Y = Y + .18810248410796732D-7 * FCTA(X)
      X = .15441527368781617D2
      Y = Y + .68283193308711996D-6 * FCTA(X)
      X = .12214223368866159D2
      Y = Y + .14844586873981299D-4 * FCTA(X)
      X = .9438314336391939D1
      Y = Y + .20427191530827846D-3 * FCTA(X)
      X = .70703385350482341D1
      Y = Y + .18490709435263109D-2 * FCTA (X)
      X = .50780186145497679D1
      Y = Y + .11299900080339453D-1 * FCTA(X)
      X = .34370866338932066D1
      Y = Y + .47328928694125219D-1 * FCTA(X)
      X = .21292836450983806D1
      Y = Y + .13629693429637754D0 * FCTA(X)
      X = .11410577748312269D1
      Y = Y + .26579577764421415D0 * FCTA(X)
      X = .46269632891508083D0
      Y = Y + .33105785495088417D0 * FCTA(X)
      X = .876494104789274D-1
      Y = Y + .20615171495780099D0 * FCTA(X)
      RETURN
      END

C *-
C *
C * CALCULATE THE DOUBLE FACTORIAL FOR ODD ARGUMENT ONLY
C *
      FUNCTION DBFAC(N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      IFAC=1
      L=1
      IF (N.LE.1) GO TO 1
   10 L=L+2
      IFAC=IFAC*L
      IF (L.LT.N) GO TO 10
    1 DBFAC=FLOAT(IFAC)
      RETURN
      END

C *-
      SUBROUTINE SPHPRJ(IPROJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL SAVED
      EXTERNAL PROJ

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D+00)
      PARAMETER (SQRT2=1.414213562373095D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /NMBRS /  PI, PITERM, PITERN, ICANON
      COMMON /RDATA/ R(NRPTSX),NRPTS
      COMMON /RINP / RX(NRPTSX),NRX
      COMMON /SPPRJ/ RVAL,MSYM(NOCCX),MOINDI,L,INDCON,M,ITEST
      COMMON /BASIS/ IBSS
      COMMON /MODAT2/ B(NNUCMX),Z(NNUCMX),C(NOCCX,NNUCMX,NSTOMX),
     $     NOCP(NOCCX),NBFN(NOCCX,NNUCMX),NCT,NMO,IPARI(NOCCX)
      COMMON /MOLTYP/ IHETRO
      COMMON /SAVEIT/ PHISIN(NQANGX,NRPTSX),ITHET,IRVAL,SAVED
      DIMENSION LSTART(NOCCX)

      COMMON /INDATA1/NTYPE(NCBFNX),NFIRST(NCBFNX),NLAST(NCBFNX)
     $     ,NR(NTMX,3),MORB(NOCCX),NBFXX,NTXX
     $     ,NGXX,NCXX,NON,NCBFN,NOCC
      COMMON /INDATA2/ VLIST(NCMX,4),ETAG(NGMX,5)
C *
C * THIS ROUTINE CALCULATES THE MO SPHERICAL HARMONIC EXPANSIONS
C * REVISED BY TLG 8/10/85
C *
C * THIS ROUTINE CAN HANDLE SIGMA, PI, AND POLARIZED ORBITALS IF THE
C * DISTORTING PARTICLE WAS LOCATED ON THE Z-AXIS.
C *
      READ (5,*) LMAX
      READ (5,*) (LSTART(I), I=1,NMO)
      LSTEP=1
      IF (IHETRO.EQ.0) LSTEP=2
      IRE=NRPTS
      IF (ABS(IPROJ) .EQ. 1) IRE=NRX
      IF (IPROJ .LT. 0) THEN
         WRITE (6,*) ' Total number of radial points in MO expansion is'
     $        ,IRE
         DO IR = 1,IRE
            RVAL=R(IR)
            IF (IPROJ .EQ. -1) RVAL = RX(IR)
            WRITE (10) RVAL
C           WRITE (10,'(f10.5)') RVAL
         ENDDO
      ENDIF

      DO MOIND = 1, NMO
         IF (IBSS .EQ. 1) THEN
            M = MORB(MOIND)

C *
C * WE FORM PI(+1)=-1/SQRT2 *[PI(X) + i*PI(Y)]
C * FOR CYLINDRICALLY SYMMETRIC CHARGE DISTRIBUTIONS,
C * THE XZ-PLANE CAN BE CHOSEN SO THAT PI(Y) DOES NOT
C * CONTRIBUTE.  SO WE SKIP PI(Y) MO'S.
C *
            IF (M .EQ. 2) GO TO 101
         ELSE
            M=MSYM(MOIND)
         END IF
         LSTRT=LSTART(MOIND)
         WRITE (6,100) M,LSTRT
         IF (M .GT. LSTRT) THEN
            WRITE (6,*) '  *** INPUT ERROR:M > L FOR ORBITAL',MOIND
     $           ,'***'
            STOP
         END IF
         MOINDI=MOIND
 100     FORMAT(//' MO WITH MSYM =',I3,' AND LSTART =',I3/)
         SAVED=.FALSE.
         DO L=LSTRT,LMAX,LSTEP
            IF (L.NE.LSTRT) SAVED=.TRUE.
            WRITE (6,110) L
 110        FORMAT(10X,'L =',I3,7X,'R',10X,'PHI(L,M)')
            IF ((IBSS .EQ. 1) .AND. (M .EQ. 1)) THEN

C *
C * FOR MO'S FROM POLYATOM GTO'S WE USE THE CONDON & SHORTLEY
C * PHASE FOR THE YLM'S.  FOR THE CASES CONSIDERED HERE, NAMELY
C * M=0, AND M=1; WE HAVE (-1)**M * XNR(L,M).  THIS DOESN'T 
C * AFFECT THE M=O FCN.  FOR AN M=1 FCN CONTSTRUCTED FROM A
C * CARTESIAN PI-X ORBITAL, WE GET AN EXTRA FACTOR OF -1/SQRT(2).
C *
               XNRFAC=SQRT2*PI*XNR(L,M)
            ELSE
               XNRFAC=TWO*PI*XNR(L,M)
            END IF
            DO IR=1,IRE
               RVAL=R(IR)
               IRVAL=IR
               IF (ABS(IPROJ) .EQ. 1) RVAL = RX(IR)
               IF (RVAL .LT. 1.D-08 .AND. IPROJ .GT. 0) GO TO 10
               ITHET=0

C * if ifun=0 call FUNCTION FCT
C * if ifun=1 call FUNCTION PROJ
C 9-5-95 WKT CALL DQG32(ZERO,PI,PROJ,PINT)
               CALL DQG32(ZERO,PI,1,PINT)
               PHILM=XNRFAC*RVAL*PINT
               WRITE (6,120) RVAL,PHILM
 120           FORMAT(18X,F10.5,4X,1PD15.8)
               WRITE (10) PHILM
C              WRITE (10,'(f20.10)') PHILM
 10            CONTINUE
            ENDDO
         ENDDO
 101     continue
      ENDDO
      RETURN
      END

C *-
        DOUBLE PRECISION FUNCTION PROJ(THETA)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        LOGICAL SAVED

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12,NLAMMX=41)
      PARAMETER (LAMMX=40)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /PRMANG/ QANG(NQANGX),SN(NQANGX),CS(NQANGX),PLSNQA(NQANGX
     $     ,0:LAMMX)
      COMMON /SPPRJ/ RVAL,MSYM(NOCCX),MOIND,L,INDCON,M,ITEST
      COMMON /SAVEIT/ PHISIN(NQANGX,NRPTSX),ITHET,IRVAL,SAVED

      ITHET=ITHET+1
      IF (SAVED .EQV. .FALSE.) THEN
         CALL TRIGFN(RVAL,THETA,INDCON,ITHET,ITEST)
         IF (ITEST .EQ. 1) THEN
            PHISIN(ITHET,IRVAL)=CALCMO(MOIND,INDCON)*DSIN(THETA)
         ELSE
            PHISIN(ITHET,IRVAL)=CALCMO(MOIND,INDCON)*SN(ITHET)
         END IF
      END IF
      PROJ=PML(L,M,THETA)*PHISIN(ITHET,IRVAL)
      RETURN
      END

C *-
C *   
C * THIS SUBROUTINE READS AND SETS UP THE R-MESH.
C *    
C * IF IPLOT=1, A CARTESIAN MESH IS READ AND SET UP FOR X AND Z.
C *    
C *

      SUBROUTINE MESH(IPLOT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /RINP/ RMESH(NRPTSX),NRIN
      COMMON /PLTMSH/ XMAX,ZMAX,XSTEP,XVAL,ZVAL,NXPTS,NZPTS
      IF (IPLOT .EQ. 1) THEN

C *
C * >>>> IPLOT OPTION <<<<
C *
         READ (5,*) XMAX,ZMAX,XSTEP
         XMAX=DABS(XMAX)
         ZMAX=DABS(ZMAX)
         XSTEP=DABS(XSTEP)
         IF (XSTEP .NE. ZERO) THEN
            NXPTS=(TWO*XMAX/XSTEP) + ONE
            NZPTS=(TWO*ZMAX/XSTEP) + ONE
         ELSE
            WRITE (6,*) '  *** XSTEP=0.0D0 ***'
            STOP
         END IF
         XMSH1= -XMAX
         ZMSH1= -ZMAX
         WRITE (6,*) '  XMESH:',XMSH1,'TO',XMAX,'  STEPSIZE=',XSTEP
         WRITE (6,*) '  ZMESH:',ZMSH1,'TO',ZMAX,'  STEPSIZE=',XSTEP
         RETURN
      ELSE

C        READ (5,504) NRMESH
         READ (5,*)   NRMESH
         WRITE (6,604) NRMESH
         WRITE (6,650)
         J = 0
         DO I = 1, NRMESH

C           READ (5,502) RSTART,RSTEP,RSTOP
            READ (5,*)   RSTART,RSTOP,RSTEP
            WRITE (6,605) RSTART,RSTEP,RSTOP

C *
C * NOTE THAT THE FIRST POINT R WILL BE RSTART  IN
C * MESH RANGE 1
C *
            RIN = RSTART
 30         J = J + 1
            RMESH(J) = RIN
            RIN = RIN + RSTEP
            IF (DABS(RIN-RSTOP) .LE. 1.0D-06) GO TO 40
            IF (RIN .GT. RSTOP) GO TO 40
            GO TO 30
 40         CONTINUE
         ENDDO
         J = J + 1
         RMESH(J) = RSTOP
         NRIN = J
         WRITE (6,673) NRIN
         IF (NRIN.LE.NRPTSX) GO TO 60
         WRITE (6,1010) NRPTSX
         STOP
 60      CONTINUE
         RMAX = RSTOP
      END IF
      RETURN

 502  FORMAT(3F10.5)
 504  FORMAT(I5,16A1,2I5)
 604  FORMAT(' ',23X,'R-VALUES',I3,'  MESHES'/)
 605  FORMAT(' ',15X,3(F10.5,2X))
 650  FORMAT(' ',19X,'RSTART',5X,'RSTEP',8X,'RSTOP')
 673  FORMAT(///' ',20X,'NUMBER OF R-POINTS IN INPUT MESH = ', I5///)
 1010 FORMAT(/1X,10('*'),5X,'SORRY, DIMENSIONED SIZE FOR R IS ',I5)

      END

C *-
C *
C * THIS SUBROUTINE READS STO FUNCTIONS.
C * THE DISTANCES B(J) ARE IN BOHR (ATOMIC UNITS)
C * B(J) IS A SIGNED QUANTITY.  IT IS NEGATIVE IF THE JTH
C * CENTER IS TO THE LEFT OF THE COORDINATE ORIGIN, POSITIVE IF
C * THE CENTER IS TO THE RIGHT.  B(J) = 0 IF THE ORIGIN IS AT
C * THE JTH CENTER  (FOR J = 2 ONLY WITH NCT = 3)
C * PARITY = +1 FOR GERADE  = -1 FOR UNGERADE MOS
C *

      SUBROUTINE RDSTO(IHETRO,INDCON)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      PARAMETER (NQANGX=32,NRPTSX=700,NNUCMX=3,NSTOMX=12)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0,TWO=2.0D0)
      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      COMMON /MODAT1/ ETA(NOCCX,NNUCMX,NSTOMX),N(NOCCX,NNUCMX,NSTOMX)
     $     ,L(NOCCX,NNUCMX,NSTOMX),M(NOCCX,NNUCMX,NSTOMX)
      COMMON /MODAT2/ B(NNUCMX),Z(NNUCMX),C(NOCCX,NNUCMX,NSTOMX),
     $     NOCP(NOCCX),NBFN(NOCCX,NNUCMX),NCT,NMO,IPARI(NOCCX)

      READ (5,506) NCT,NMO
      WRITE (6,1006)
      WRITE (6,651)
      WRITE (6,607) NCT,NMO
      IF (IHETRO .EQ. 0) NCT = NCT - 1
      DO I=1,NMO

C *
C * SEE ALAM WRITE-UP FOR NOCP,TITLMO AND IPARI
C *
         READ (5,504) NOCP(I),TITLMO,IPARI(I)
         WRITE (6,617) TITLMO
         WRITE (6,618) I
         DO J = 1,NCT
            READ (5,505) NBFN(I,J),B(J),Z(J)
            WRITE (6,608) J,NBFN(I,J),B(J)
            WRITE (6,609) NOCP(I),IPARI(I),Z(J)
            KUPR = NBFN(I,J)
            WRITE (6,653)
            DO K = 1,KUPR
               READ (5,506) N(I,J,K),L(I,J,K),M(I,J,K),C(I,J,K),ETA(I,J
     $              ,K)
               WRITE (6,610)N(I,J,K),L(I,J,K),M(I,J,K),C(I,J,K),ETA(I,J
     $              ,K)
            ENDDO
         ENDDO
      ENDDO

      IF (IHETRO .EQ. 0) CALL CCALC(INDCON)
      RETURN

 504  FORMAT(I5,16A1,2I5)
 505  FORMAT(I5,2F10.5)
 506  FORMAT(3I5,2F10.5)
 607  FORMAT(' ',15X,I3,2X,'NUCLEAR CENTERS',10X,I3,2X,
     $     'MOLECULAR ORBITALS'/)
 608  FORMAT(//' ',20X,'CENTER ',I2,5X,I5,' BASIS FUNCTIONS ',5X,
     $     'LOCATION = ',F10.5,' BOHR '/)
 609  FORMAT(' ',20X,'OCCUPATION NUMBER = ',I2,5X,'PARITY = ',I3, 5X
     $     ,'CHARGE = ',F6.2//)
 610  FORMAT(' ',20X,3(I3,2X),F10.5,5X,F10.5)
 617  FORMAT(//' ',20X,'DATA FOR THE ',16A1,' MOLECULAR ORBITAL')
 618  FORMAT(' ',20X,'ORBITAL NUMBER ',I5/)
 651  FORMAT(///' ',30X,'MOLECULAR ORBITAL DATA'/)
 653  FORMAT(' ',22X,'N',4X,'L',4X,'M',7X,'C',15X,'ETA')
 1006 FORMAT(/' SLATER-TYPE-ORBITAL BASIS SET'/)

      END

C *-
C *
C * POLYINTS PROGRAM -- MQM MASTER FILE LOG
C * INITIAL CREATION -- 10/28/74 -- BDO
C * LPPOLY LOCAL POTENTIAL INTEGRAL PROGRAM - WRITTEN BY CBM 12-1-70
C * ADDED TO PREVIOUS POLYATOM PROGRAM
C * PROGRAM MODIFIED TO USE IJLK OR PAIR TAPES, RVB 09/06/75
C * FORTRAN IV PROGRAM  PA300 (TAPE3,TAPE4,INPUT,OUTPUT,TAPE5=INPUT,
C *

      SUBROUTINE POLY(NPRNT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      PARAMETER (NGMX=800,NTMX=84,NCMX=84,NCBFNX=700,NOCCX=25)

      CHARACTER*6 ITYPE(NCMX)
C     CHARACTER*4 ILBL,ICENTR
      CHARACTER*4 ILBL
      CHARACTER*4 ORBT
      COMMON /LCAOMO/D(NCBFNX,NOCCX)
      COMMON /INDATA1/NTYPE(NCBFNX),NFIRST(NCBFNX),NLAST(NCBFNX)
     $     ,NR(NTMX,3),MORB(NOCCX),NBFXX,NTXX
     $     ,NGXX,NCXX,NON,NCBFN,NOCC
      COMMON /INDATA2/ VLIST(NCMX,4),ETA(NGMX,5)
      DIMENSION NCNTR(NCBFNX),NUMBER(NCBFNX),ICENTR(NCMX),C(NGMX)
      DIMENSION LPSKIP(NCMX),ORBT(18),NR2(NTMX,3)

      COMMON /LABELS/  ILBL(18)
      COMMON /IOIND /  ICON(10)
      COMMON /NMBRS /  PI, PITERM, PITERN, ICANON
      EQUIVALENCE (ICON1,ICON(1)),(ICON2,ICON(2))
      EQUIVALENCE (ICON10,ICON(10))

      DATA  NR2/  
     $     0,
     $     1,0,0,
     $     2,0,0,1,1,0,
     $     3,0,0,2,2,1,0,1,0,1,
     $     4,0,0,3,3,1,0,1,0,2,2,0,2,1,1,
     $     5,0,0,4,4,1,0,1,0,3,3,2,0,2,0,3,1,1,2,2,1,
     $     6,0,0,5,5,1,0,1,0,4,4,2,0,2,0,4,1,1,3,3,0,3,3,2,1,2,1,2,
     $     0,
     $     0,1,0,
     $     0,2,0,1,0,1,
     $     0,3,0,1,0,2,2,0,1,1,
     $     0,4,0,1,0,3,3,0,1,2,0,2,1,2,1,
     $     0,5,0,1,0,4,4,0,1,2,0,3,3,0,2,1,3,1,2,1,2,
     $     0,6,0,1,0,5,5,0,1,2,0,4,4,0,2,1,4,1,3,0,3,2,1,3,3,1,2,2,
     $     0,
     $     0,0,1,
     $     0,0,2,0,1,1,
     $     0,0,3,0,1,0,1,2,2,1,
     $     0,0,4,0,1,0,1,3,3,0,2,2,1,1,2,
     $     0,0,5,0,1,0,1,4,4,0,2,0,2,3,3,1,1,3,1,2,2,
     $     0,0,6,0,1,0,1,5,5,0,2,0,2,4,4,1,1,4,0,3,3,1,2,1,2,3,3,2/
C
C * copy from gamess/inputb.src
      DATA  ITYPE/
     $ '    S ',
     $ '    X ','    Y ','    Z ',
     $ '   XX ','   YY ','   ZZ ','   XY ','   XZ ','   YZ ',
     $ '   XXX','   YYY','   ZZZ','   XXY','   XXZ','   YYX' ,'   YYZ',
     $ '   ZZX','   ZZY','   XYZ',
     $ '  XXXX','  YYYY','  ZZZZ','  XXXY','  XXXZ','  YYYX','  YYYZ',
     $ '  ZZZX','  ZZZY','  XXYY','  XXZZ','  YYZZ','  XXYZ','  YYXZ',
     $ '  ZZXY',
     $ ' XXXXX',' YYYYY',' ZZZZZ',' XXXXY',' XXXXZ',' YYYYX',' YYYYZ',
     $ ' ZZZZX',' ZZZZY',' XXXYY',' XXXZZ',' YYYXX',' YYYZZ',' ZZZXX',
     $ ' ZZZYY',' XXXYZ',' YYYXZ',' ZZZXY',' XXYYZ',' XXZZY',' YYZZX',
     $ '    X6','    Y6','    Z6','   X5Y','   X5Z',
     $ '   Y5X','   Y5Z','   Z5X','   Z5Y','  X4Y2',
     $ '  X4Z2','  Y4X2','  Y4Z2','  Z4X2','  Z4Y2',
     $ '  X4YZ','  Y4XZ','  Z4XY','  X3Y3','  X3Z3',
     $ '  Y3Z3',' X3Y2Z',' X3Z2Y',' Y3X2Z',' Y3Z2X',
     $ ' Z3X2Y',' Z3Y2X','X2Y2Z2'/

      DO I=1,3
         DO J=1,NTMX
            NR(J,I)=NR2(J,I)
         ENDDO
      ENDDO
      NCXX=NCMX
      NTXX=NTMX
      NBFXX=NCBFNX
      NGXX=NGMX
      PI=3.141592653589793D0
      PITERM=2.D0/PI**0.5D0
      PITERN=PI**1.5D0
      CALL RDINPT(NCBFNX,NGMX,NCMX,NTMX,MAXTYP,NCBFN,NGAUS,NOC,C,ETA
     $     ,NUMBER,NCNTR,NTYPE,NFIRST,NLAST,ICENTR,VLIST,ITYPE,NR,NON
     $     ,LPSKIP,NOCC)
      IF (NOCC .GT. NOCCX) THEN
         WRITE (6,*) '  *****TOO MANY ORBITALS: INCREASE NOCCX*****'
         STOP
      END IF

C *
C * READ THE ORBITAL CLASSIFICATION : MORB(I), I=1,NOCC
C *
C * MORB=0 --> SIGMA
C * MORB=1 --> PI-X
C * MORB=2 --> PI-Y
C *

C     READ (5,500) (MORB(I), I=1,NOCC)
      READ (5,*)   (MORB(I), I=1,NOCC)
      DO I=1,NOCC
         IF ((MORB(I) .LT. 0) .OR. (MORB(I) .GT. 2)) THEN
            WRITE (6,*) '   *****ERROR IN CLASSIFICATION,MORB(I)='
     $           ,MORB(I),'  FOR I=',I
          STOP
       ELSE
          WRITE (6,*) '               MORB(',I,')=',MORB(I)
       END IF
       READ (5,113) (ORBT(K),K=1,18)
       READ (5,112) (D(J,I),J=1,NCBFN)
C      READ (5,*)   (D(J,I),J=1,NCBFN)
      ENDDO
 113  FORMAT(18A4)

      IF (NPRNT.EQ.0) GO TO 777
      WRITE (6,1234)
 1234 FORMAT(//'**** LCAO:MO MATRIX D ****')
      CALL PRINT(D,NCBFNX,NOCCX,NCBFN,NOCC)
 777  CONTINUE

 112  FORMAT(5D15.8)
 500  FORMAT(36I2)

C *
C * CALCULATE  THE  OVERLAP  INTEGRALS  AND  CHECK  NORMALIZATION
C *

      CALL GINTS(NTYPE,NR,NFIRST,NLAST,ETA,NCBFNX,NTMX,NGMX,NCBFN,NOCC
     $     ,NPRNT)

      RETURN
      END

C *-
C *
C *
C * ICON DEFINITIONS
C *
C * ICON(1) - CALCULATE
C *  0 = 1E AND 2E
C *  1 = 1E ONLY
C *  2 = 1E AND CHANGE SOME 2E (MLIST)
C *  3 = 1E AND COPY 2E
C *  4 = 1E, COPY 2E AND ADD BFNS
C *  5 = 1E, COPY 2E AND RESTART 2E
C *
C * ICON(2) - TAPE IN
C *  0 = NONE
C *  1 = POLYATOM
C *  2 = POLYIJLK
C *  3 = POLYPAIR
C *  4 = POLYPAIR + IJLK
C *
C * ICON(3) - NORMALIZE
C *  0 = YES
C *  1 = NO
C *
C * ICON(4) - CHECK SYMMETRY
C *  0 = YES
C *  1 = NO
C *

      SUBROUTINE RDINPT (NBFXX,NGXX,NCXX,NTXX,MAXTYP,NCBFN,NGAUS,NOC,C
     $     ,ETA,NUMBER,NCNTR,NTYPE,NFIRST,NLAST,ICNTR,VLIST,ITYPE,NR
     $     ,NON,LPSKIP, NOCC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*6 ITYPE(NTXX), KTYP
      CHARACTER*4 IBLNK, IJLK, JKPR
      CHARACTER*8 BLANK, WZERO(3), ZRO(3)
C     CHARACTER*4 ILBL,KCNT,ICNTR
      CHARACTER*4 ILBL

C *
C * VALID COMBINATIONS OF ICON(1) AND ICON(2)
C *
C *   ICON(2)
C *           0    1    2    3    4
C *   ICON(1)
C *      0    X    X    X
C *      1    X
C *      2         X    X
C *      3         X    X    X    X
C *      4         X    X
C *      5         X

      DIMENSION  C(NGXX), ETA(NGXX,5), NUMBER(NBFXX), NCNTR(NBFXX),
     $     NTYPE(NBFXX), NFIRST(NBFXX), NLAST(NBFXX), ICNTR(NCXX),
     $     VLIST(NCXX,4), NR(NTXX,3)
      DIMENSION LPSKIP(NCXX)
      DIMENSION NCON(30)
      COMMON /IOIND /  ICON(10)
      COMMON /LABELS/  ILBL(18)
      COMMON /NMBRS /  PI, PITERM, PITERN, ICANON
      EQUIVALENCE (ICON1,ICON(1)),(ICON2,ICON(2)),(ICON3,ICON(3)),
     $     (ICON4,ICON(4)),(ICON9,ICON(9)),(ICON10,ICON(10))
      DATA NCON/1,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,0,0,0,1,0,
     $     0,0/
      DATA IBLNK/'    '/
      DATA BLANK/'        '/
      DATA IJLK,JKPR/'IJLK','JKPR'/
      DATA ZRO/' ZERO CO','EF SET T','O ONE   '/
      ICANON =  2
      IERR=0

C *
C * READ AND PRINT THE PROBLEM LABEL.
C *
      READ (5,930) (ILBL(II),II=1,18)

C *
C * READ AND PRINT THE CONTROL OPTIONS.
C *

C     READ (5,900)  ICON
      READ (5,*)    ICON
      IF (ICON1.EQ.2) ICON9=1
      IF (ICON1.LT.0.OR.ICON1.GT.5) GO TO 710
      IF (ICON2.LT.0.OR.ICON2.GT.4) GO TO 710
      IF (NCON(5*ICON1+ICON2+1).EQ.0) GO TO 710
      ICON10=ICON2
      IF (ICON1.GE.4) ICON10=0
      ILBL(18)=IBLNK
      IF (ICON1.NE.4.AND.ICON2.EQ.2) ILBL(18)=IJLK
      IF (ICON2.GE.3) ILBL(18)=JKPR

      WRITE (6,931) (ILBL(II),II=1,18)

      WRITE (6,901)  ICON
      GO TO 670

 710  IERR = IERR + 1

      WRITE (6,931) (ILBL(II),II=1,18)

      WRITE (6,901)  ICON

      WRITE (6,935)

C *
C * READ AND PRINT THE CENTER COORDINATES.
C *

670   WRITE (6,671)

      WRITE (6,672) NGXX,NBFXX
      WRITE (6,673) NCXX

      WRITE (6,674)
 671  FORMAT(//5X,'PROGRAM LIMITATIONS')
 672  FORMAT(/5X,'MAX NO GAUSSIAN PRIMATIVES=   ',I4 /5X
     $     ,     'MAX NO BASIS    FUNCTIONS =   ',I4)
 673  FORMAT(/5X,'MAX NO CENTERS=  ',I4)
 674  FORMAT(/5X,  'S,P,D,F,G,H,I TYPE GAUSSIANS ONLY')

C     READ (5,918) NON, NAC
      READ (5,*)   NON, NAC

      WRITE (6,904)  NON, NAC
      NOC=NON+NAC
      IF (NON.LE.NCXX.AND.NOC.LE.NCXX) GO TO 60
      IERR =  IERR + 1

      WRITE (6,940)
      NON=MIN0(NON,NCXX)
      NAC=MIN0(NAC,NCXX-NON)

 60   WRITE (6,905)
      DO I = 1, NON

C        READ (5,906)  ICNTR(I), (VLIST(I,J),J=1,4)
         READ (5,*)    ICNTR(I), (VLIST(I,J),J=1,4)

         WRITE (6,907) ICNTR(I), (VLIST(I,J),J=1,4)
      ENDDO
      IF (NAC .LE. 0)   GO TO  90
      K = NON + 1
      L = NON+NAC

      WRITE (6,908)
      DO I = K, L

C        READ (5,906)  ICNTR(I), (VLIST(I,J),J=1,4)
         READ (5,*)    ICNTR(I), (VLIST(I,J),J=1,4)

         WRITE (6,907) ICNTR(I), (VLIST(I,J),J=1,4)
      ENDDO

C *
C * READ AND CHECK THE BASIS FUNCTIONS.
C *

C90   READ (5,918)NGAUS, NCBFN, NOCC
 90   READ (5,*)  NGAUS, NCBFN, NOCC

      WRITE (6,909)  NGAUS, NCBFN,NOCC
      IF (NGAUS .LE. NGXX)   GO TO  100
      IERR = IERR + 1

      WRITE (6,941)
      NGAUS = NGXX
 100  IF (NCBFN .LE. NBFXX)   GO TO  110
      IERR =  IERR + 1

      WRITE (6,942)
      NCBFN = NBFXX

C110  READ (5,915)(NUMBER(I),I=1,NCBFN)
 110  READ (5,*)  (NUMBER(I),I=1,NCBFN)
      IF (NCBFN .NE. NGAUS)   GO TO  114
      DO I = 1, NCBFN
         NUMBER(I) =  1
      ENDDO
 114  NFIRST(1) = 1
      IF (NUMBER(1) .EQ. 0) NUMBER(1) = 1
      NLAST(1) = NUMBER(1)
      DO I = 2, NCBFN
         NFIRST(I) = NLAST(I-1) + 1
         IF (NUMBER(I) .EQ. 0) NUMBER(I) = 1
         NLAST(I) = NLAST(I-1) + NUMBER(I)
      ENDDO
      IF (NLAST(NCBFN) .EQ. NGAUS)  GO TO  130
      IERR = IERR + 1
      WRITE (6,943)
 130  MAXTYP =  1
      I =  0
      DO JO = 1, NCBFN
         ISAVE = 0
         ISF = NUMBER(JO)
         DO K = 1, ISF
            I =  I + 1
            IF (ISAVE .NE. 0)  GO TO  160

            READ (5,910) KCNT, KTYP, INC, EXPNT, C(I)
            IF (INC .EQ. 0)   GO TO  170
            IF (INC .GT. 0 .AND. INC .LT. JO)  GO TO   140
            IERR =  IERR + 1

            WRITE (6,944) JO, KCNT, KTYP, INC
            GO TO  300
 140        IF (NUMBER(INC) .EQ. ISF) GO TO 150
            IERR =  IERR + 1

            WRITE (6,945)  JO, INC
            ISF =  NUMBER(INC)
 150        II =  NFIRST(INC)
            ISAVE =  1
 160        C(I) =  C(II)
            EXPNT =  ETA(II,4)
            II =  II + 1
 170        IF (EXPNT .NE. 0.  D0)  GO TO  180
            IERR = IERR + 1

            WRITE (6,946)
 180        DO MM=1,3
               WZERO(MM)=BLANK
            ENDDO
            IF (C(I).NE.0.D0) GO TO 190
            C(I) =  1.D0
            DO MM=1,3
               WZERO(MM)=ZRO(MM)
            ENDDO
 190        IF (K .EQ. 1  .OR.  IERR .NE. 0)   GO TO  230
            IF (KCNT .EQ. ICNTR(JA))   GO TO  210
            IERR = IERR + 1

            WRITE (6,948)  JO, K
 210        IF (KTYP .EQ. ITYPE(JB))   GO TO  270
            IERR = IERR + 1

            WRITE (6,949)  JO, K
            GO TO  270
 230        DO JT = 1, NOC
               JA =  JT
               IF (KCNT .EQ. ICNTR(JA))   GO TO  250
            ENDDO
            IERR = IERR + 1

            WRITE (6,950)  JO
 250        DO JT = 1, NTXX
               JB =  JT
               IF (KTYP .EQ. ITYPE(JB))   GO TO  270
            ENDDO
            IERR = IERR + 1
            WRITE (6,951) JO

 270        NCNTR(JO) = JA
            NTYPE(JO) = JB

            WRITE (6,1911) I,JO,K,KCNT,KTYP,EXPNT,C(I),
     $           (WZERO(MJ),MJ=1,3)
            DO  M=1,3
               ETA(I,M) =  VLIST(JA,M)
            ENDDO
            ETA(I,4) =  EXPNT
            IF (JB .GT. MAXTYP)   MAXTYP =  JB
         ENDDO
 300     CONTINUE
      ENDDO

      IF (IERR .EQ. 0)   GO TO  330
      DO KK=1,NOC
         LPSKIP(KK)=1
      ENDDO

      WRITE (6,952)  IERR
      STOP

C *
C * ARE THE BASIS FUNCTIONS IN STANDARD ORDER.
C *

 330  DO JO = 2, NCBFN
         IF (NTYPE(JO) .GE. NTYPE(JO-1))  GO TO  340
         ICANON =  1

         WRITE (6,922)
         GO TO  400
 340     CONTINUE
      ENDDO

      WRITE (6,923)

 400  DO KK = 1, NOC
         LPSKIP(KK)=1
      ENDDO

C *
C * NORMALIZE THE PRIMITIVE FUNCTIONS
C *
      DO I = 1, NCBFN
         ITYP =  NTYPE(I)
         L =  NR(ITYP,1)
         M =  NR(ITYP,2)
         N =  NR(ITYP,3)
         IS =  NFIRST(I)
         IF =  NLAST(I)
         DO II=IS,IF
            T =  0.5D0/ETA(II,4)
            SOO =  PITERN*T**1.5D0
            T1 =  OVLAP(L,L,0.0D0,0.0D0,T)
            T2 =  OVLAP(M,M,0.0D0,0.0D0,T)
            T3 =  OVLAP(N,N,0.0D0,0.0D0,T)
            GII =  SOO*T1*T2*T3
            ETA(II,5) =  1.0D0/DSQRT(GII)
         ENDDO
      ENDDO

C *
C * IF (ICON(3) .EQ. 1)   GO TO  550
C * RENORMALIZE THE BASIS FUNCTIONS.
C *

      WRITE (6,916)
      DO I = 1, NCBFN
         ITYP = NTYPE(I)
         L = NR(ITYP,1)
         M = NR(ITYP,2)
         N = NR(ITYP,3)
         IS = NFIRST(I)
         IF = NLAST(I)
         PRTINT = 0.D0
         DO II = IS, IF
            DO JJ = IS, IF
               T =  1.0D0/(ETA(II,4) + ETA(JJ,4))
               SOO =  PITERN*(T**1.5D0)*ETA(II,5)*ETA(JJ,5)
               T1  =  OVLAP(L,L,0.0D0,0.0D0,T)
               T2  =  OVLAP(M,M,0.0D0,0.0D0,T)
               T3  =  OVLAP(N,N,0.0D0,0.0D0,T)
               PRTINT = PRTINT + C(II)*C(JJ)*SOO*T1*T2*T3
            ENDDO
         ENDDO
         PRTINT = 1.0D0/DSQRT(PRTINT)
         DO K=IS,IF
            C(K) = C(K)*PRTINT
            ETA(K,5) = ETA(K,5)*C(K)
            IJ =  K - IS + 1
            WRITE (6,917) K,I,IJ,NCNTR(I),NTYPE(I),NR(ITYP,1),NR(ITYP,2)
     $           ,NR(ITYP,3),ETA(K,4),C(K),ETA(K,5)
         ENDDO
      ENDDO
      WRITE (6,919)
      NONM1 =  NON - 1
      DO I = 1, NONM1
         IP1 =  I + 1
         DO J = IP1, NON
            RIJ = DSQRT((VLIST(I,1) - VLIST(J,1))**2 + 
     $                  (VLIST(I,2) - VLIST(J,2))**2 + 
     $                  (VLIST(I,3) - VLIST(J,3))**2)
            RIJA =  RIJ*0.529167D0
            WRITE (6,920)  ICNTR(I), ICNTR(J), RIJ, RIJA
         ENDDO
      ENDDO
      RETURN

 900  FORMAT (10I5)
 901  FORMAT (/ 3X, 'PROGRAM  CONTROL  OPTIONS  ...  ',10I5 )
 904  FORMAT (/ 3X, 'NUMBER  OF  NUCLEI =', I5, 15X,
     $     'NUMBER  OF  ADDITIONAL  CENTERS =', I5)
 905  FORMAT (/ 10X, '* *  NUCLEAR  CENTERS  * * '//3X, 'CENTE
     $     R', 18X, 'COORDINATES ', 17X, 'CHARGE',5X,'LOCAL POTENTIAL',/
     $     )
 906  FORMAT(A4,6X,4F12.8,2X,A8)
C907  FORMAT (3X, A4, 6X, 3F12.8, 6X, F4.1 ,5X,A8)
 907  FORMAT (3X, I4, 6X, 3F12.8, 6X, F4.1 ,5X,A8)
 908  FORMAT (/ 10X, '* *  ADDITIONAL  CENTERS  * * '/ 3X, 'CENTER', 18X
     $     , 'COORDINATES'/)
 909  FORMAT (// 10X, '* *  GAUSSIAN  FUNCTION  SPECIFICATIONS  * *' /
     $     /3X,'NUMBER OF PRIMITIVE GAUSSIANS =',I5 / 3X,
     $     'NUMBER  OF  BASIS  FUNCTIONS  =', I5 //
     $     '    NUMBER OF OCCUPIED ORBITALS=',I5// 3X,'GAUSSIAN', 3X,
     $     'FUNCTION', 3X, 'COMPONENT', 3X, 'CENTER', 4X, 'TYPE', 6X,
     $     'EXPONENT', 6X, 'COEFFICIENT')
 910  FORMAT (I2, A6, I2, 3X, F13.6, X, F13.6)
 1911 FORMAT(3(3X,I5,3X), 4X,I4,6X,A6,2F15.7,2X,3A8)
 915  FORMAT (36I2)
 916  FORMAT (10X,  '* *  RENORMALIZE  THE  BASIS  FUNCTIONS  * *' // 3X
     $     , 'GAUSSIAN', 3X, 'FUNCTION', 3X, 'COMPONENT', 3X, 'CENTER',
     $     4X, 'TYPE', 5X, 'L', 5X, 'M', 5X, 'N', 6X, 'EXPONENT', 6X,
     $     'COEFFICIENT'  ,6X,'   ETA(K,5)')
 917  FORMAT (3X,I5,6X,I5,6X,I4,5X,I6,4X,I6,1X,3I6,2X,3D15.8)
 918  FORMAT (24I3)
 919  FORMAT (// 10X, 'INTERNUCLEAR DISTANCES FROM GEOMETRY' // 8X
     $     ,' CENTERS',11X, 'A.U.', 10X, 'A.')
C920  FORMAT (5X, A4, ' - ', A4, 2F14.6)
 920  FORMAT (5X, I4, ' - ', I4, 2F14.6)
 922  FORMAT (/3X,'THE BASIS FUNCTIONS ARE NOT IN STANDARD ORDER')
 923  FORMAT (/3X,'THE BASIS FUNCTIONS ARE LISTED IN STANDARD ORDER')
  930 FORMAT(18A4)
  931 FORMAT(//5X,18A4 //)
 935  FORMAT(//10X
     $     ,'**  INCOMPATIBLE  ICON(1)  AND  ICON(2)  PARAMETERS **'/)
 940  FORMAT (// 10X,'**  TOO  MANY  CENTERS  **'/)
 941  FORMAT (// 10X,'**  TOO MANY  PRIMITIVES  **'/)
 942  FORMAT (// 10X,'**  TOO  MANY  FUNCTION  **'/)
 943  FORMAT (// 10X,'**  ERROR  IN  NUMBER  OF  PRIMITIVES  PER',
     $     ' FUNCTION  **'/)
 944  FORMAT (// 10X,'**  INCORRECT  PREVIOUS  FUNCTION  FOR',
     $     ' FUNCTION',I4,6X,'KCNT= ',I4,'  KTYP= ',A4,'  INC=',I4,
     $     '  **' /)
 945  FORMAT (// 10X,'**  NUMBER OF PRIVITIVES IN FUNCTIONS',I5, ' AND'
     $     ,I5,'  NOT EQUAL  **'/)
 946  FORMAT (// 10X,'**  ZERO  EXPONENT  **'/)
 948  FORMAT (// 10X,'**  CENTERS  NOT  SAME FOR  FUNCTION ',I5,5X,
     $     'PRIMITIVE ',I4,'  **' /)
 949  FORMAT (// 10X,'**  TYPES  NOT  SAME  FOR  FUNCTION',I5,5X,
     $     'PRIMITIVE ',I4,'  **' /)
 950  FORMAT (// 10X,'**  UNDEFINED  CENTER  FOR  FUNCTION',I5,'  **')
 951  FORMAT (// 10X,'**  UNALLOWED  TYPE  FOR  FUNCTION',I5,'  **'/)
 952  FORMAT(//10X,'**',I3
     $     ,'  ERROR(S).  ANOTHER  RUN  FOR  THE  SEUCR MAN  **'/)
      END

C *-
      SUBROUTINE PRINT(A,MD,ND,M,N) 
      DOUBLE PRECISION A          
      DIMENSION A(MD,ND)
      N6=N/6
      NI=1  
      IF (N6.LT.1) GO TO 200         
      NN=N-N6*6         
      NL=6  
      DO IN=1,N6    
         WRITE (6,300) ((A(I,J),J=NI,NL),I=1,M)     
         NI=NI+6           
         NL=NL+6           
      ENDDO
      IF (NN.EQ.0) RETURN

 200  WRITE (6,400) 
 400  FORMAT(' ')       
      DO I=1,M      
         WRITE (6,600) (A(I,J),J=NI,N)         
      ENDDO
 600  FORMAT(1x,6(3X,D15.8))      
 300  FORMAT(//6(3X,D15.8))         
      RETURN
      END   

C *-
      SUBROUTINE GINTS(NTYPE,NR,NFIRST,NLAST,ETA,NBFXX,NTXX,NGXX,NCBFN
     $     ,NOCC,NPRNT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      INTEGER OUT
      PARAMETER (NOCCX=25,NCBFNX=700,OUT=6)
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)

      DIMENSION NTYPE(NBFXX),ETA(NGXX,5),NFIRST(NBFXX),NLAST(NBFXX),
     $     NR(NTXX,3)
      COMMON /IOIND /  ICON(10)
      COMMON /NMBRS /  PI, PITERM, PITERN, ICANON
      COMMON /LCAOMO/D(NCBFNX,NOCCX)
      COMMON /OVERLP/OVPM(NOCCX,NOCCX),OVS(NCBFNX,NCBFNX),S(NCBFNX)

      IERR = 0
      DO J=1,NCBFN
         DO I=1,J
            OVLAPA=ZERO
            ITYP=NTYPE(I)
            JTYP=NTYPE(J)
            L1=NR(ITYP,1)
            L2=NR(JTYP,1)
            M1=NR(ITYP,2)
            M2=NR(JTYP,2)
            N1=NR(ITYP,3)
            N2=NR(JTYP,3)
            IS=NFIRST(I)
            IF=NLAST(I)
            JS=NFIRST(J)
            JF=NLAST(J)
            DO II=IS,IF
               A=ETA(II,4)
               DO JJ=JS,JF
                  B=ETA(JJ,4)
                  T=1.D0/(A+B)
                  P1=(A*ETA(II,1)+B*ETA(JJ,1))*T
                  P2=(A*ETA(II,2)+B*ETA(JJ,2))*T
                  P3=(A*ETA(II,3)+B*ETA(JJ,3))*T
                  AB1=ETA(II,1)-ETA(JJ,1)
                  AB2=ETA(II,2)-ETA(JJ,2)
                  AB3=ETA(II,3)-ETA(JJ,3)
                  DISTAB=AB1*AB1+AB2*AB2+AB3*AB3
                  SOO=(PITERN*T**1.5D0)*DEXP(-A*B*DISTAB*T)*ETA(II,5)
     $                 *ETA(JJ,5)
                  PAX=P1-ETA(II,1)
                  PBX=P1-ETA(JJ,1)
                  PAY=P2-ETA(II,2)
                  PBY=P2-ETA(JJ,2)
                  PAZ=P3-ETA(II,3)
                  PBZ=P3-ETA(JJ,3)
                  T1=OVLAP(L1,L2,PAX,PBX,T)
                  T2=OVLAP(M1,M2,PAY,PBY,T)
                  T3=OVLAP(N1,N2,PAZ,PBZ,T)
                  OVLAPA=OVLAPA+SOO*T1*T2*T3
               ENDDO
            ENDDO
            OVS(I,J)=OVLAPA
            OVS(J,I)=OVLAPA
         ENDDO
      ENDDO
      DO J=1,NOCC
         DO K=1,NCBFN
            X=ZERO
            DO L=1,NCBFN
               X=X + OVS(K,L)*D(L,J)
            ENDDO
            S(K)=X
         ENDDO
         DO I=1,J
            Y=ZERO
            DO K=1,NCBFN
               Y=Y + D(K,I)*S(K)
            ENDDO
            OVPM(I,J)=Y
            OVPM(J,I)=Y
         ENDDO
      ENDDO
      DO I=1,NOCC
         IF (DABS(OVPM(I,I) - ONE) .GT. 1.0D-04) THEN
            IERR=IERR + 1
            WRITE (OUT,*) 'NORMALIZATION FOR ORBITAL',I,'=',OVPM(I,I)
         ELSE
            WRITE (OUT,*) '  ** NORMALIZATION CHECK OK **'
         END IF
      ENDDO
      IF (IERR .NE. 0) THEN
         WRITE (OUT,*) 'EXECUTION TERMINATED IN GINTS, IERR=',IERR
         STOP
      END IF
      IF (NPRNT .GT. 1) THEN
         WRITE (6,860)
 860     FORMAT(//'### ATOMIC OVERLAP MATRIX ###')
         CALL PRINT(OVS,NCBFNX,NCBFNX,NCBFN,NCBFN)
      END IF
      IF (NPRNT .GT. 0) THEN
         WRITE (6,888)
 888     FORMAT(//'### OVERLAP MATRIX OF NOCC BY NOCC ###')
         CALL PRINT(OVPM,NOCCX,NOCCX,NOCC,NOCC)
      END IF
      RETURN
      END

C *-
C * THIS SUBROUTINE CALCULATES THE CARTESIAN PRIMITIVE INTEGRALS FOR
C * THE ATOMIC OVERLAP INTEGRALS.
C *

      DOUBLE PRECISION FUNCTION OVLAP (L,M,A,B,T)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LL=L+1
      MM=M+1
      IF (L .GE. 4 .OR. M .GE. 4) THEN
         OVLAP = OVLAP_GEN(L,M,A,B,T)
         RETURN
      ENDIF
      IF (LL .EQ. 2) GO TO 101
      IF (LL .EQ. 3) GO TO 102
      IF (LL .EQ. 4) GO TO 103
      IF (LL .EQ. 5) GO TO 104
      IF (LL .EQ. 6) GO TO 105
      IF (MM .EQ. 1) GO TO 110
      IF (MM .EQ. 2) GO TO 111
      IF (MM .EQ. 3) GO TO 112
      IF (MM .EQ. 4) GO TO 113
      IF (MM .EQ. 5) GO TO 200
      IF (MM .EQ. 6) GO TO 200
 101  IF (MM .EQ. 1) GO TO 120
      IF (MM .EQ. 2) GO TO 121
      IF (MM .EQ. 3) GO TO 122
      IF (MM .EQ. 4) GO TO 123
      IF (MM .EQ. 5) GO TO 200
      IF (MM .EQ. 6) GO TO 200
 102  IF (MM .EQ. 1) GO TO 130
      IF (MM .EQ. 2) GO TO 131
      IF (MM .EQ. 3) GO TO 132
      IF (MM .EQ. 4) GO TO 133
      IF (MM .EQ. 5) GO TO 200
      IF (MM .EQ. 6) GO TO 200
 103  IF (MM .EQ. 1) GO TO 140
      IF (MM .EQ. 2) GO TO 141
      IF (MM .EQ. 3) GO TO 142
      IF (MM .EQ. 4) GO TO 143
      IF (MM .EQ. 5) GO TO 200
      IF (MM .EQ. 6) GO TO 200
 104  IF (MM .EQ. 1) GO TO 150
      IF (MM .EQ. 2) GO TO 151
      IF (MM .EQ. 3) GO TO 152
      IF (MM .EQ. 4) GO TO 153
      IF (MM .EQ. 5) GO TO 200
      IF (MM .EQ. 6) GO TO 200
 105  IF (MM .EQ. 1) GO TO 160
      IF (MM .EQ. 2) GO TO 161
      IF (MM .EQ. 3) GO TO 162
      IF (MM .EQ. 4) GO TO 163
      IF (MM .EQ. 5) GO TO 200
      IF (MM .EQ. 6) GO TO 200
 200  WRITE (6,201) L,M,A,B,T
 201  FORMAT (//2I5,3F17.7,' ERROR IN OVLAP')
      STOP

C * ......00
 110  OVLAP=1.D0
      GO TO 300

C * ......01
 111  OVLAP=B
      GO TO 300

C * ......02
 112  OVLAP=B*B+0.5D0*T
      GO TO 300
C * .....03
 113  OVLAP=B*(B*B+1.5D0*T)
      GO TO 300
C * ......10
 120  OVLAP=A
      GO TO 300
C * ......11
 121  OVLAP=A*B+0.5D0*T
      GO TO 300

C * ......12
 122  OVLAP=A*B*B+T*(B+0.5D0*A)
      GO TO 300

C * .....13
 123  OVLAP=B*(B*(B*A+1.5D0*T)+1.5D0*A*T)+0.75D0*T*T
      GO TO 300
C * ......20
 130  OVLAP=A*A+0.5D0*T
      GO TO 300

C * ......21
 131  OVLAP=A*A*B+T*(A+0.5D0*B)
      GO TO 300

C * ......22
 132  OVLAP=A*A*B*B+T*(0.5D0*(A*A+B*B)+2.D0*A*B+0.75D0*T)
      GO TO 300

C * .....23
 133  AA=A*A
      TT=T*T
      OVLAP=B*(B*(B*(AA+0.5D0*T)+3.D0*A*T)+1.5D0*AA*T+2.25D0*TT)+1.5D0*A
     $     *TT
      GO TO 300

C * ......30
 140  OVLAP=A*(A*A+1.5D0*T)
      GO TO 300

C * ......31
 141  OVLAP=A*(A*(A*B+1.5D0*T)+1.5D0*B*T)+0.75D0*T*T
      GO TO 300

C * ......32
 142  BB=B*B
      TT=T*T
      OVLAP=A*(A*(A*(BB+0.5D0*T)+3.D0*B*T)+1.5D0*BB*T+2.25D0*TT)+1.5D0*B
     $     *TT
      GO TO 300

C * .....33
 143  AB=A*B
      ABAB=A*A+3.D0*AB+B*B
      OVLAP=AB*(AB*AB+1.5D0*T*ABAB)+T*T*(2.25D0*ABAB+1.875D0*T)
      GO TO 300

C * ......40
 150  OVLAP=A*A*(A*A+3.D0*T)+0.75D0*T*T
      GO TO 300

C * ......41
 151  OVLAP=A*(A*(A*(A*B+2.D0*T)+3.D0*B*T)+3.D0*T*T)+0.75D0*B*T*T
      GO TO 300

C * ......42
 152  BB=B*B
      TT=T*T
      OVLAP=A*(A*(A*(A*(BB+0.5D0*T)+4.D0*B*T)+3.D0*BB*T+4.5D0*TT)+6.D0*B
     $     *TT)+TT*(0.75D0*BB+1.875D0*T)
      GO TO 300

C * .....43
 153  T2=T*T
      B2=B*B
      OVLAP=A*(A*(A*(A*(B*(B2+1.5D0*T))+3.D0*T*(2.D0*B2+T))+3.D0*B*T*(B2
     $     +4.5D0*T))+T2*(9.D0*B2+7.5D0*T))+B*T2*(0.75D0*B2+5.625D0*T)
      GO TO 300

C * .....50
 160  A2=A*A
      OVLAP=A*(5.D0*T*(0.75D0*T+A2)+A2*A2)
      GO TO 300

C * .....51
 161  T2=T*T
      OVLAP=A*(A*(A*(A*(A*B+2.5D0*T)+5.D0*B*T)+7.5D0*T2)+3.75D0*B*T2)+1
     $     .875D0*T*T2
      GO TO 300

C * .....52
 162  T2=T*T
      B2=B*B
      OVLAP=A*(A*(A*(A*(A*(0.5D0*T+B2)+5.D0*B*T)+5.D0*B2*T+7.5D0*T2)+15
     $     .D0*B*T2)+T2*(3.75D0*B2+9.375D0*T))+3.75D0*B*T*T2
      GO TO 300

C * .....53
 163  U=T/2.D0
      U2=U*U
      A2=A*A
      A4=A2*A2
      B2=B*B
      AB=A*B
      OVLAP=AB*A4*B2+U*(3.D0*AB*A4+15.D0*A4*B2+10.D0*A2*B2*AB)+3.D0*U2
     $     *(5.D0*A4+30.D0*A2*AB+30.D0*A2*B2+5.D0*AB*B2)+15.D0*U*U2*(10
     $     .D0*A2+15.D0*AB+3.D0*B2)+105.D0*U2*U2

 300  CONTINUE
      RETURN
      END
C * OVERLAP INTEGRAL 
C * REF:  GUANGXIAN XU, LEMIN LI, DEMIN WANG, QUANTUM CHEMISTRY, P.571
      DOUBLE PRECISION FUNCTION OVLAP_GEN(L,M,A,B,T)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      IMAX = (L+M)/2
      S = 0.0
      DO I = 0, IMAX
         FAC = 1.0
         DO J = 2*I-1, 1, -2
            FAC = FAC * J
         ENDDO
         S = S + FI(2*I,L,M,A,B)*FAC*(T/2)**I
      ENDDO
      OVLAP_GEN = S
      RETURN
      END
      DOUBLE PRECISION FUNCTION FI(I,L,M,A,B)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      S = 0.0
      DO LAM = 0, L
         DO MU = 0, M
            IF (LAM+MU .NE. I) GOTO 100
            S = S + BINOM(L,LAM)*BINOM(M,MU)*A**(L-LAM)*B**(M-MU)
 100        CONTINUE
         ENDDO
      ENDDO
      FI = S
      RETURN
      END
      DOUBLE PRECISION FUNCTION BINOM(L,M)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      BINOM = FAC(L)/FAC(M)/FAC(L-M)
      RETURN
      END
      DOUBLE PRECISION FUNCTION FAC(L)
      FAC = 1.0
      DO I = 1, L
         FAC = FAC * I
      ENDDO
      RETURN 
      END

C *-
C *
C * this code performs a 32 pt gauss-legendre quadrature
C * using an external function fct.  the result is returned
C * in y.
C *
C * if ifun=0 call FUNCTION FCT
C * if ifun=1 call FUNCTION PROJ

C 9-5-95 WKT subroutine dqg32(xl,xu,fct,y)
      subroutine dqg32(xl,xu,ifun,y)
      implicit double precision (a-h,o-z)
      if (ifun.eq.0) then
         a=.5d0*(xu+xl)
         b=xu-xl
         c=.49863193092474078d0*b
         y=.35093050047350483d-2*(fct(a+c)+fct(a-c))
         c=.49280575577263417d0*b
         y=y+.8137197365452835d-2*(fct(a+c)+fct(a-c))
         c=.48238112779375322d0*b
         y=y+.12696032654631030d-1*(fct(a+c)+fct(a-c))
         c=.46745303796886984d0*b
         y=y+.17136931456510717d-1*(fct(a+c)+fct(a-c))
         c=.44816057788302606d0*b
         y=y+.21417949011113340d-1*(fct(a+c)+fct(a-c))
         c=.42468380686628499d0*b
         y=y+.25499029631188088d-1*(fct(a+c)+fct(a-c))
         c=.39724189798397120d0*b
         y=y+.29342046739267774d-1*(fct(a+c)+fct(a-c))
         c=.36609105937014484d0*b
         y=y+.32911111388180923d-1*(fct(a+c)+fct(a-c))
         c=.33152213346510760d0*b
         y=y+.36172897054424253d-1*(fct(a+c)+fct(a-c))
         c=.29385787862038116d0*b
         y=y+.39096947893535153d-1*(fct(a+c)+fct(a-c))
         c=.25344995446611470d0*b
         y=y+.41655962113473378d-1*(fct(a+c)+fct(a-c))
         c=.21067563806531767d0*b
         y=y+.43826046502201906d-1*(fct(a+c)+fct(a-c))
         c=.16593430114106382d0*b
         y=y+.45586939347881942d-1*(fct(a+c)+fct(a-c))
         c=.11964368112606854d0*b
         y=y+.46922199540402283d-1*(fct(a+c)+fct(a-c))
         c=.7223598079139825d-1*b
         y=y+.47819360039637430d-1*(fct(a+c)+fct(a-c))
         c=.24153832843869158d-1*b
         y=b*(y+.48270044257363900d-1*(fct(a+c)+fct(a-c)))
      else if (ifun.eq.1) then
         a=.5d0*(xu+xl)
         b=xu-xl
         c=.49863193092474078d0*b
         y=.35093050047350483d-2*(proj(a+c)+proj(a-c))
         c=.49280575577263417d0*b
         y=y+.8137197365452835d-2*(proj(a+c)+proj(a-c))
         c=.48238112779375322d0*b
         y=y+.12696032654631030d-1*(proj(a+c)+proj(a-c))
         c=.46745303796886984d0*b
         y=y+.17136931456510717d-1*(proj(a+c)+proj(a-c))
         c=.44816057788302606d0*b
         y=y+.21417949011113340d-1*(proj(a+c)+proj(a-c))
         c=.42468380686628499d0*b
         y=y+.25499029631188088d-1*(proj(a+c)+proj(a-c))
         c=.39724189798397120d0*b
         y=y+.29342046739267774d-1*(proj(a+c)+proj(a-c))
         c=.36609105937014484d0*b
         y=y+.32911111388180923d-1*(proj(a+c)+proj(a-c))
         c=.33152213346510760d0*b
         y=y+.36172897054424253d-1*(proj(a+c)+proj(a-c))
         c=.29385787862038116d0*b
         y=y+.39096947893535153d-1*(proj(a+c)+proj(a-c))
         c=.25344995446611470d0*b
         y=y+.41655962113473378d-1*(proj(a+c)+proj(a-c))
         c=.21067563806531767d0*b
         y=y+.43826046502201906d-1*(proj(a+c)+proj(a-c))
         c=.16593430114106382d0*b
         y=y+.45586939347881942d-1*(proj(a+c)+proj(a-c))
         c=.11964368112606854d0*b
         y=y+.46922199540402283d-1*(proj(a+c)+proj(a-c))
         c=.7223598079139825d-1*b
         y=y+.47819360039637430d-1*(proj(a+c)+proj(a-c))
         c=.24153832843869158d-1*b
         y=b*(y+.48270044257363900d-1*(proj(a+c)+proj(a-c)))
      endif
      return
      end

C *-
C * SVD FIT (C) Copr. 1986-92 Numerical Recipes Software )E14.

	SUBROUTINE FUNCS(X,AFUNC,MA)
	REAL*8 X,AFUNC(MA)
	INTEGER MA
 
	AFUNC(1) = 1.0D0
	AFUNC(2) = X
	AFUNC(3) = LOG(X)

	END

C *-
      SUBROUTINE SVDFIT(X,Y,SIG,NDATA,A,MA,U,V,W,MP,NP,CHISQ,FUNCS)
      INTEGER MA,MP,NDATA,NP,NMAX,MMAX
      REAL*8 CHISQ,A(MA),SIG(NDATA),U(MP,NP),V(NP,NP),W(NP),X(NDATA),
     $     Y(NDATA),TOL
      EXTERNAL FUNCS
      PARAMETER (NMAX=1000,MMAX=50,TOL=1.E-5)

CU    USES SVBKSB,SVDCMP
      INTEGER I,J
      REAL*8 SUM,THRESH,TMP,WMAX,AFUNC(MMAX),B(NMAX)
      DO 12 I=1,NDATA
         CALL FUNCS(X(I),AFUNC,MA)
         TMP=1./SIG(I)
         DO 11 J=1,MA
            U(I,J)=AFUNC(J)*TMP
 11      CONTINUE
         B(I)=Y(I)*TMP
 12   CONTINUE
      CALL SVDCMP(U,NDATA,MA,MP,NP,W,V)
      WMAX=0.
      DO 13 J=1,MA
         IF(W(J).GT.WMAX)WMAX=W(J)
 13   CONTINUE
      THRESH=TOL*WMAX
      DO 14 J=1,MA
         IF(W(J).LT.THRESH)W(J)=0.
 14   CONTINUE
      CALL SVBKSB(U,W,V,NDATA,MA,MP,NP,B,A)
      CHISQ=0.
      DO 16 I=1,NDATA
         CALL FUNCS(X(I),AFUNC,MA)
         SUM=0.
         DO 15 J=1,MA
            SUM=SUM+A(J)*AFUNC(J)
 15      CONTINUE
         CHISQ=CHISQ+((Y(I)-SUM)/SIG(I))**2
 16   CONTINUE
      RETURN
      END

C *-
      SUBROUTINE SVDCMP(A,M,N,MP,NP,W,V)
      INTEGER M,MP,N,NP,NMAX
      REAL*8 A(MP,NP),V(NP,NP),W(NP)
      PARAMETER (NMAX=500)
CU    USES PYTHAG
      INTEGER I,ITS,J,JJ,K,L,NM
      REAL*8 ANORM,C,F,G,H,S,SCALE,X,Y,Z,RV1(NMAX),PYTHAG
      G=0.0
      SCALE=0.0
      ANORM=0.0
      DO 25 I=1,N
         L=I+1
         RV1(I)=SCALE*G
         G=0.0
         S=0.0
         SCALE=0.0
         IF(I.LE.M)THEN
            DO 11 K=I,M
               SCALE=SCALE+ABS(A(K,I))
 11         CONTINUE
            IF(SCALE.NE.0.0)THEN
               DO 12 K=I,M
                  A(K,I)=A(K,I)/SCALE
                  S=S+A(K,I)*A(K,I)
 12            CONTINUE
               F=A(I,I)
               G=-SIGN(SQRT(S),F)
               H=F*G-S
               A(I,I)=F-G
               DO 15 J=L,N
                  S=0.0
                  DO 13 K=I,M
                     S=S+A(K,I)*A(K,J)
 13               CONTINUE
                  F=S/H
                  DO 14 K=I,M
                     A(K,J)=A(K,J)+F*A(K,I)
 14               CONTINUE
 15            CONTINUE
               DO 16 K=I,M
                  A(K,I)=SCALE*A(K,I)
 16            CONTINUE
            ENDIF
         ENDIF
         W(I)=SCALE *G
         G=0.0
         S=0.0
         SCALE=0.0
         IF((I.LE.M).AND.(I.NE.N))THEN
            DO 17 K=L,N
               SCALE=SCALE+ABS(A(I,K))
 17         CONTINUE
            IF(SCALE.NE.0.0)THEN
               DO 18 K=L,N
                  A(I,K)=A(I,K)/SCALE
                  S=S+A(I,K)*A(I,K)
 18            CONTINUE
               F=A(I,L)
               G=-SIGN(SQRT(S),F)
               H=F*G-S
               A(I,L)=F-G
               DO 19 K=L,N
                  RV1(K)=A(I,K)/H
 19            CONTINUE
               DO 23 J=L,M
                  S=0.0
                  DO 21 K=L,N
                     S=S+A(J,K)*A(I,K)
 21               CONTINUE
                  DO 22 K=L,N
                     A(J,K)=A(J,K)+S*RV1(K)
 22               CONTINUE
 23            CONTINUE
               DO 24 K=L,N
                  A(I,K)=SCALE*A(I,K)
 24            CONTINUE
            ENDIF
         ENDIF
         ANORM=MAX(ANORM,(ABS(W(I))+ABS(RV1(I))))
 25   CONTINUE
      DO 32 I=N,1,-1
         IF(I.LT.N)THEN
            IF(G.NE.0.0)THEN
               DO 26 J=L,N
                  V(J,I)=(A(I,J)/A(I,L))/G
 26            CONTINUE
               DO 29 J=L,N
                  S=0.0
                  DO 27 K=L,N
                     S=S+A(I,K)*V(K,J)
 27               CONTINUE
                  DO 28 K=L,N
                     V(K,J)=V(K,J)+S*V(K,I)
 28               CONTINUE
 29            CONTINUE
            ENDIF
            DO 31 J=L,N
               V(I,J)=0.0
               V(J,I)=0.0
 31         CONTINUE
         ENDIF
         V(I,I)=1.0
         G=RV1(I)
         L=I
 32   CONTINUE
      DO 39 I=MIN(M,N),1,-1
         L=I+1
         G=W(I)
         DO 33 J=L,N
            A(I,J)=0.0
 33      CONTINUE
         IF(G.NE.0.0)THEN
            G=1.0/G
            DO 36 J=L,N
               S=0.0
               DO 34 K=L,M
                  S=S+A(K,I)*A(K,J)
 34            CONTINUE
               F=(S/A(I,I))*G
               DO 35 K=I,M
                  A(K,J)=A(K,J)+F*A(K,I)
 35            CONTINUE
 36         CONTINUE
            DO 37 J=I,M
               A(J,I)=A(J,I)*G
 37         CONTINUE
         ELSE
            DO 38 J= I,M
               A(J,I)=0.0
 38         CONTINUE
         ENDIF
         A(I,I)=A(I,I)+1.0
 39   CONTINUE
      DO 49 K=N,1,-1
         DO 48 ITS=1,30
            DO 41 L=K,1,-1
               NM=L-1
               IF((ABS(RV1(L))+ANORM).EQ.ANORM)  GOTO 2
               IF((ABS(W(NM))+ANORM).EQ.ANORM)  GOTO 1
 41         CONTINUE
 1          C=0.0
            S=1.0
            DO 43 I=L,K
               F=S*RV1(I)
               RV1(I)=C*RV1(I)
               IF((ABS(F)+ANORM).EQ.ANORM) GOTO 2
               G=W(I)
               H=PYTHAG(F,G)
               W(I)=H
               H=1.0/H
               C= (G*H)
               S=-(F*H)
               DO 42 J=1,M
                  Y=A(J,NM)
                  Z=A(J,I)
                  A(J,NM)=(Y*C)+(Z*S)
                  A(J,I)=-(Y*S)+(Z*C)
 42            CONTINUE
 43         CONTINUE
 2          Z=W(K)
            IF(L.EQ.K)THEN
               IF(Z.LT.0.0)THEN
                  W(K)=-Z
                  DO 44 J=1,N
                     V(J,K)=-V(J,K)
 44               CONTINUE
               ENDIF
               GOTO 3
            ENDIF
C           IF(ITS.EQ.30) PAUSE 'NO CONVERGENCE IN SVDCMP'
            IF(ITS.EQ.30) then
               write (0,*) 'NO CONVERGENCE IN SVDCMP'
               exit
            ENDIF
            X=W(L)
            NM=K-1
            Y=W(NM)
            G=RV1(NM)
            H=RV1(K)
            F=((Y-Z)*(Y+Z)+(G-H)*(G+H))/(2.0*H*Y)
            G=PYTHAG(F,1.0D0)
            F=((X-Z)*(X+Z)+H*((Y/(F+SIGN(G,F)))-H))/X
            C=1.0
            S=1.0
            DO 47 J=L,NM
               I=J+1
               G=RV1(I)
               Y=W(I)
               H=S*G
               G=C*G
               Z=PYTHAG(F,H)
               RV1(J)=Z
               C=F/Z
               S=H/Z
               F= (X*C)+(G*S)
               G=-(X*S)+(G*C)
               H=Y*S
               Y=Y*C
               DO 45 JJ=1,N
                  X=V(JJ,J)
                  Z=V(JJ,I)
                  V(JJ,J)= (X*C)+(Z*S)
                  V(JJ,I)=-(X*S)+(Z*C)
 45            CONTINUE
               Z=PYTHAG(F,H)
               W(J)=Z
               IF(Z.NE.0.0)THEN
                  Z=1.0/Z
                  C=F*Z
                  S=H*Z
               ENDIF
               F= (C*G)+(S*Y)
               X=-(S*G)+(C*Y)
               DO 46 JJ=1,M
                  Y=A(JJ,J)
                  Z=A(JJ,I)
                  A(JJ,J)= (Y*C)+(Z*S)
                  A(JJ,I)=-(Y*S)+(Z*C)
 46            CONTINUE
 47         CONTINUE
            RV1(L)=0.0
            RV1(K)=F
            W(K)=X
 48      CONTINUE
 3       CONTINUE
 49   CONTINUE
      RETURN
      END

C *-
      SUBROUTINE SVBKSB(U,W,V,M,N,MP,NP,B,X)
      INTEGER M,MP,N,NP,NMAX
      REAL*8 B(MP),U(MP,NP),V(NP,NP),W(NP),X(NP)
      PARAMETER (NMAX=500)
      INTEGER I,J,JJ
      REAL*8 S,TMP(NMAX)
      DO 12 J=1,N
         S=0.
         IF(W(J).NE.0.)THEN
            DO 11 I=1,M
               S=S+U(I,J)*B(I)
 11         CONTINUE
            S=S/W(J)
         ENDIF
         TMP(J)=S
 12   CONTINUE
      DO 14 J=1,N
         S=0.
         DO 13 JJ=1,N
            S=S+V(J,JJ)*TMP(JJ)
 13      CONTINUE
         X(J)=S
 14   CONTINUE
      RETURN
      END

C *-
      FUNCTION PYTHAG(A,B)
      REAL*8 A,B,PYTHAG
      REAL*8 ABSA,ABSB
      ABSA=ABS(A)
      ABSB=ABS(B)
      IF(ABSA.GT.ABSB)THEN
         PYTHAG=ABSA*SQRT(1.+(ABSB/ABSA)**2)
      ELSE
         IF(ABSB.EQ.0.)THEN
            PYTHAG=0.
         ELSE
            PYTHAG=ABSB*SQRT(1.+(ABSA/ABSB)**2)
         ENDIF
      ENDIF
      RETURN
      END
