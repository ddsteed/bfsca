C     *-
C     * PROGRAM VLAM 
C     *
C     * Program to compute legendre coefficients of static potential
C     * for electron collisions with linear diatomic and triatomic molecules
C     * from legendre expansion coefficients of the target charge density
C     * in a single centre representation
C     *
C     * V1.0: L. A. COLLINS (LASL), D. W. NORCROSS (JILA) 
C     *       G. BRUNO SCHMID (JILA)
C     *-/

C     * THESE DIMENSIONS ARE AT THE DISPOSAL OF THE USER
C     *
C     * MXAL IS MAXIMUM SIZE OF INPUT ALAM ARRAYS
C     * MXVL IS MAXIMUM SIZE OF OUTPUT VLAM ARRAYS
C     * MXRG IS MAXIMUM NUMBER OF RADIAL MESH REGIONS FOR VLAM DATA
C     * MXPR IS MAXIMUM ORDER OF POWER SERIES FIT TO ALAM DATA NEAR ORIGIN

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     DIMENSION SX(MXAL),SY(MXAL),H(MXAL),DELY(MXAL),DERIV(MXAL)
      DIMENSION SX(700), SY(700), H(700), DELY(700), DERIV(700)
C     DIMENSION AMAT(MXVL),RA1(MXVL),BMAT(MXVL),YMAT(MXVL)
      DIMENSION AMAT(700), RA1(700), BMAT(700), YMAT(700)
C     DIMENSION C(MXAL,MXPR+1),INTRVL(MXVL)
      DIMENSION C(700,5), INTRVL(700)
C     DIMENSION VPOT1(MXVL),HOLD(MXVL)
      DIMENSION VPOT1(700), HOLD(700)
C     DIMENSION NH(MXRG),HN(MXRG),RMI(MXRG),RMA(MXRG),RST(MXRG)
      DIMENSION NH(10), HN(10), RMI(10), RMA(10), RST(10)
C     DIMENSION EXPN(MXPR+1),ARRY(MXPR+1,MXPR+1),IPVT(MXPR+1)
      DIMENSION EXPN(5), ARRY(5,5), IPVT(5)

C     * THESE DIMENSIONS ARE FIXED

      DIMENSION ZJ(3), RJ(3)
      CHARACTER TITLE(72)

      COMMON /TY/ ASM,PSM,QSM,RMXAL,RMAX,LAMDA
      COMMON /TZ/ EXPN,IPOWR
      COMMON /PRINT/ OUTPUT,IPRNT
      COMMON /IINT/ C,SX,CONLV1,CONLV2,INTRVL,NFIT

      INTEGER OUNIT,OUTPUT

    1 FORMAT (5X,F10.5,D24.16)
C   1 FORMAT (5X,F10.5,D23.16)
    2 FORMAT (/
     $     /' INPUT ALAM DATA AND COEFFICIENTS FOR CUBIC FIT TO ALA M('
     $     ,I2,') DATA'//10X,'R',17X,'ALAM',15X,'C(J,1)',14X,'C(J,2)'
     $     ,14X ,'C(J,3)',14X,'C(J,4)'//)
    3 FORMAT (6D20.8)
    4 FORMAT (///'  EXPANSION COEFFICIENTS OF ALAM(',I2,
     $     ') NEAR ORIGIN FOR NFIT =',I2,' AND LEADING POWER
     $     =',I3/5X, 'C(I=1,...,NFIT) = ',5D20.6)
    5 FORMAT (//' ALAM(R) = (X**(LEADING POWER))*(C(1) + C(2)*X +',
     $     ' C(3)*X**2 +...+ C(NFIT)*X**(NFIT-1))'///)
    6 FORMAT (3D24.16)
C   6 FORMAT (3D23.16)
    7 FORMAT (//' EXPANSION COEFFICIENTS OF ALAM(',I2,') AT LARGE R' /
     $     ,5X,'ASM = ',D12.4,5X,'PSM = ',D12.4,5X,'QSM = ',D12.4,//,
     $     ' ALAM(R) = ASM*R**PSM*EXP(-QSM*R)'//)
    8 FORMAT (72A1)
    9 FORMAT (//' EXPANSION COEFFICIENTS FOR THE POTENTIAL OF',2X,72A1)
 11   FORMAT (//' ALL INPUT AND OUTPUT DATA ARE IN ATOMIC UNITS'///
     $     ' LAMDA(INITIAL) =',I5,5X,' LAMDA(FINAL) =',I5,6X
     $     ,'LAMDA(STEP) =' ,I5)
 12   FORMAT (2I5)
 13   FORMAT (//' ELECTRONIC + NUCLEAR')
 14   FORMAT (//' ELECTRONIC ONLY')
 15   FORMAT (//' CENTER',5X,'CHARGE',5X,'DISTANCE')
 16   FORMAT (' ',I5,3X,F10.5,3X,F10.5)
 17   FORMAT (//'  LEADING POWER OF R FOR ALAM DATA NEAR ORIGIN NOT EQ'
     $     ,'UAL TO LAMDA'/)
 18   FORMAT (///' ARRAY DIMENSIONS EXCEEDED BY INPUT DATA')
 19   FORMAT (///' INPUT MESH SCREWED UP')
 20   FORMAT (///' PRIMARY DATA ERROR')
 21   FORMAT (2D15.6)
 22   FORMAT (//' LAST POINT OF VLAM MESH ',F10.5,' LESS THAN LAST PO','
     $     INT OF ALAM MESH ',F10.5)
 23   FORMAT (///' *NOTE* VLAM VALUE AT ORIGIN IS MEANINGLESS',/,8X,
     $     '(NUCLEAR CONTRIBUTION IS INFINITE)'///)
 24   FORMAT (///' ALAM DATA FOR LAMDA =',I3,' NOT FOUND ON FILE')
 25   FORMAT (1X)
 26   FORMAT (///' INPUT AND OUTPUT OF VLAM INTEGRAL AND EXPANSION ',
     $     'COEFFICIENT OF VLAM(',I2,') '/
     $     /' AMAT = (4*PI/(2*LAMDA+1))*ALAM' /
     $     ,' BMAT = VLAM W/O CONTRIBUTION FROM RMAX TO INFINITY AN D','
     $     W/O NUCLEAR CONTRIBUTION'///5X,'R',15X,'AMAT',16X ,'BMAT',16X
     $     , 'VLAM'/)

 27   FORMAT (F10.5,D24.16)
C27   FORMAT (F10.5,D23.16)
 28   FORMAT (F10.5,3D20.8)
 29   FORMAT (//' MESH OF',I5,' RADIAL POINTS FROM ORIGIN TO ',F10.5)
 30   FORMAT (/' COEFFICIENT OF R**LAMDA AT ORIGIN IS',D14.6/
     $     ' COEFFICIENT OF 1.0/R**(LAMDA+1) AT RMAX IS',D14.6)
 31   FORMAT (/' FRACTION OF EXACT TOTAL CHARGE FROM 0.0 TO RMAX IS',
     $     E14.6/' AND FRACTION FROM RMAX TO INFINITY IS',D14.6//
     $     ' TOTAL CALCULATED ELECTRONIC CHARGE IS',D14.6)
 32   FORMAT (' COEFFICIENT OF R**LAMDA FROM RMAX TO INFINITY IS',D14.6)
 33   FORMAT (/' PERMANENT MULTIPOLE MOMENT AT RMAX IS',D14.6//
     $     ' TOTAL CALCULATED PERMANENT MULTIPOLE MOMENT IS',D14.6)
 34   FORMAT (' VLAM MESH POINTS AND THE RESPECTIVE INTERVALS OF TH
     $     E', ' ALAM MESH WITHIN WHICH THEY LIE',//)
 35   FORMAT (10X,'II =',I5,10X,'RA1(II) = ',D20.12,5X,'INTRVL(II) = '
     $     ,I5)
 36   FORMAT (//' DETAILED INFORMATION ABOUT THE ANALYTICAL INTEGRATI','
     $     ON STEPS '//,10X,'XLP',17X,'XUP',12X,'N',9X,'J',9X,' L',14X,'
     $     C(J,L)',//)
 37   FORMAT (//' MATRIX OF EQUATIONS FOR POWER SERIES FIT NEAR',
     $     ' ORIGIN MAY BE SINGULAR'//)
 38   FORMAT (///' *WARNING* ALAM(',I2,') NOT EQUAL TO 0.0 AT ORIGIN', /
     $     //)
 39   FORMAT (///' *WARNING* VALUE FOR ALAM AS INFERRED FROM THE POWER'
     $     ,' SERIES FIT NEAR THE ORIGIN AND WITH LAMDA = 0',D20.9,/10X,
     $     ' IS NOT IN AGREEMENT (TO WITHIN ',D13.6,
     $     ' ) WITH THE VALUE READ' ,' IN FROM THE ALAM FILE ',D20.9,//
     $     /)
 40   FORMAT (3F10.5)
 41   FORMAT (///' POTENTIAL EVALUATED AT FOLLOWING R-VALUES '//4X,
     $     'RMIN',6X,'RMAX',6X,'RSTEP'/)

      DATA MXAL,MXVL,MXRG,MXNC,MXPR/700,700,10,3,4/
      DATA IUNIT,OUNIT,INPUT/2,3,5/

C *
C * NFIT = NO. OF R-VALUES OF ALAM MESH NEAR ORIGIN TO BE FIT
C * WITH A POYNOMIAL OF ORDER NFIT-1 (NFIT MUST BE
C * .LE. MXPR+1)
C * CONLV1,CONLV2 = CONFIDENCE LEVELS USED WITH ALL LOGICAL TESTS
C *    
      NFIT=5
      CONLV1=1.0D-04
      CONLV2=1.0D-04

C * I AM CHANGING GOOGOL FROM 1.0D+100 TO 1.0D+60  TO PREVENT
C * MACHINE OVERFLOW.  TOM GIBSON  6/25/79
C * GOOGOL=1.0D+37
      GOOGOL=1.0D+300
      FPI=12.56637062D+00
C *
C * ******************
C * DATA INPUT SECTION
C * ******************
C *    
C * PRIMARY CONTROL DATA
C *    
C * LMINI = INITIAL VALUE OF LAMDA DESIRED
C * LMIN = INITIAL VALUE OF LAMDA WANTED, PLUS 1
C * ALAM FILE WILL BE SEARCHED SEQUENTIALLY FOR THIS VALUE
C * LMAXI = FINAL VALUE OF LAMDA DESIRED
C * LMAX = FINAL VALUE OF LAMDA WANTED, PLUS 1
C * MUST BE .GE. LMIN
C * MUST BE .LE. LAST VALUE OF ALAM DATA
C * LSTEP = INCREMENT IN LAMDA FROM LMIN TO LMAX
C * NREG = NUMBER OF MESH REGIONS FOR VLAM OUTPUT
C * MUST BE .LE. MXRG
C * ICASE = 1 FOR ELECTRONIC PLUS NUCLEAR VLAM OUTPUT
C * 2 FOR ELECTRONIC VLAM OUTPUT ONLY
C * IRW3 = 0 FOR CREATION OF NEW OUTPUT FILE
C *      = NOT 0 FOR ADDITION TO PREVIOUSLY CREATED OUTPUT FILE
C * IPRNT = 0,1,2 OR 3 FOR SUCCESSIVELY HIGHER PRINT LEVEL
C * IFLG = PRINT CONTROL, VLAM OUTPUT PRINTED IN IFLG STEPS
C *      = 0 FOR NO POINTS OF VLAM OUTPUT PRINTED
C *

C wkt 0,6,2,4,1,0,1,1
C DEFAULT VALUES  IPRNT=IFLG=0
C wkt READ (INPUT,10) LMINI,LMAXI,LSTEP,NREG,ICASE,IRW3,IPRNT,IFLG
      READ (INPUT,*)  LMINI,LMAXI,LSTEP,NREG,ICASE,IRW3,IPRNT,IFLG
      LMIN=LMINI+1
      LMAX=LMAXI+1
      IF (LMIN.LT.1.OR.LMAX.LT.LMIN.OR.LSTEP.GT.LMAX-LMIN+1) GO TO 80
      IF (NREG.LT.1.OR.ICASE.LT.1.OR.ICASE.GT.2) GO TO 80
      IF (IPRNT.LT.0.OR.IPRNT.GT.3) IPRNT=0
      IF (IFLG.LT.0) IFLG=0

C *
C * **************************************************
C * READ TITLE OF ALAM INPUT FILE AND VLAM OUTPUT FILE
C * READ VLAM MESH
C * **************************************************
C *    
C * RMI(I) = INITIAL VALUE OF R IN VLAM MESH BLOCK I
C * MUST BE 0.0 FOR I=1
C * RMA(I) = FINAL VALUE OF R IN VLAM MESH BLOCK I
C * RMA(I) MUST EQUAL RMI(I+1)
C * RMA(NREG) MUST BE .GE. TO THE LAST POINT
C * PROVIDED FOR THE ALAM DATA
C * RST(I) = INCREMENT OF R IN VLAM MESH BLOCK I
C * TOTAL NUMBER OF MESH POINTS MUST BE .LE. MXVL
C *
      REWIND IUNIT
      IF (IRW3.EQ.0) REWIND OUNIT
      READ (IUNIT,8) TITLE
      IF (IRW3.EQ.0) WRITE (OUNIT,8) TITLE
      WRITE (OUTPUT,9) TITLE
      LMNM1=LMIN-1
      LMXM1=LMAX-1
      WRITE (OUTPUT,11) LMNM1,LMXM1,LSTEP
      IF (ICASE.EQ.1) WRITE (OUTPUT,13)
      IF (ICASE.EQ.2) WRITE (OUTPUT,14)
      WRITE (OUTPUT,41)
      IF (IRW3.EQ.0) WRITE (OUNIT,12) NREG
      DO IK=1,NREG

C wkt    READ (INPUT,40) RMI(IK),RMA(IK),RST(IK)
         READ (INPUT,*)  RMI(IK),RMA(IK),RST(IK)
         IF (IRW3.EQ.0)  WRITE (OUNIT,40) RMI(IK),RMA(IK),RST(IK)
         WRITE (OUTPUT,40) RMI(IK),RMA(IK),RST(IK)
      ENDDO

C *
C * ***************
C * CHECK VLAM MESH
C * ***************
C *
C * NCT = NUMBER OF CENTERS, MUST BE .LE. 3
C * LAMAX = LARGEST VALUE OF LAMDA FOR WHICH VALUES OF
C * A-LAMDA EXIST ON IUNIT
C * ZJ(I) = CHARGE OF NUCLEUS AT CENTER I
C * RJ(I) = DISTANCE OF NUCLEUS I FROM CENTER OF MASS, IN A.U.
C * MUST BE .LT. 0.0 FOR CENTER TO LEFT OF C.M.
C * MUST BE .GE. 0.0 FOR CENTER TO RIGHT OF C.M.
C * NUCLEAR POTENTIAL TERMS FOR RJ .LT. 0.0 HAVE
C * ADDITIONAL PHASE (-1.0)**LAMDA ADDED
C *    
      IF (NREG.GT.MXRG) GO TO 78
      IF (RMI(1).NE.0.0D+00) GO TO 79
      IMAX=1
      DO 43 IK=1,NREG
         RSTRT=RMI(IK)
         RSTEP=RST(IK)
         RSTOP=RMA(IK)
         IF (RSTEP.LT.1.0D-05) GO TO 79
         HN(IK)=RSTEP
         NPTS=(RSTOP-RSTRT)/RSTEP+CONLV1
         IF (DABS(RSTRT+NPTS*RSTEP-RSTOP).GE.CONLV1) GO TO 79
         NH(IK)=NPTS
         IMAX=IMAX+NPTS
         IF (IMAX.GT.MXVL) GO TO 78
         IF (IK.EQ.1) GO TO 43
         IF (RSTRT.NE.RMA(IK-1)) GO TO 79
 43   CONTINUE
      RMAX=RMA(NREG)
      WRITE (OUTPUT,29) IMAX,RMAX
      WRITE (OUTPUT,15)
      READ (IUNIT,12) NCT,LAMAX
      IF (LMAX.GT.LAMAX+1) GO TO 80
      IF (IRW3.EQ.0) WRITE (OUNIT,12) NCT
      IF (NCT.GT.MXNC) GO TO 78
      ZN=0.0D+00
      DO IK=1,NCT
         READ (IUNIT,21) ZJ(IK),RJ(IK)
         IF (IRW3.EQ.0) WRITE (OUNIT,21) ZJ(IK),RJ(IK)
         WRITE (OUTPUT,16) IK,ZJ(IK),RJ(IK)
         ZN=ZN+ZJ(IK)
      ENDDO

C *     
C * **************
C * READ ALAM DATA
C * **************
C *     
C * LAMIN = VALUE OF LAMDA, SET TO .LT. 0 FOR TERMINATOR
C * INPUT DATA MUST BE IN ORDER OF INCREASING LAMDA
C * NPTS = NUMBER OF TABULAR RADIAL POINTS, MUST BE .LE. MXAL
C * SX(I) = VALUE OF R AT RADIAL TABULAR POINT I
C * SY(I) = VALUE OF ALAM AT RADIAL TABULAR POINT I
C * ASM, PSM, QSM = CONSTANTS IN EXPONENTIAL FIT TO ALAM FOR LARGE R
C * (R .GE.R(NPTS)) OF THE FORM ASM*R**PSM*EXP(-QSM*R)
C * 
      DO 77 LL=LMIN,LMAX,LSTEP
         LAMDA=LL-1
         FPOVL=FPI/FLOAT(2*LAMDA+1)
 45      READ (IUNIT,12) LAMIN,NPTS
         IF (LAMIN.LT.0) GO TO 82
         IF (NPTS.GT.MXAL) GO TO 78
         READ (IUNIT,1) (SX(I),SY(I),I=1,NPTS)
         READ (IUNIT,6) ASM,PSM,QSM
         RMXAL=SX(NPTS)
         IF ((RMAX-RMXAL).LT.-CONLV1) GO TO 81
         IF (LAMIN.NE.LAMDA) GO TO 45
         IMAXM=IMAX-1
         WRITE (OUNIT,12) LAMDA,IMAXM

C *     
C * SET-UP VLAM MESH
C * (AUTOMATICALLY USES AN EXPONENTIAL FIT TO GENERATE ALAM AT
C * POINTS OF THE VLAM MESH GREATER THAN THE LAST POINT OF THE
C * INPUT ALAM MESH)
C *
         R=RMI(1)
         RA1(1)=RMI(1)
         IT1=1
         DO IK=1,NREG
            NNN=NH(IK)
            RSTEP=HN(IK)
            DO IL=1,NNN
               IT1=IT1+1
               R=R+RSTEP
               RA1(IT1)=R
            ENDDO
         ENDDO
         DO I1=1,IMAX
            IF (RA1(I1).LE.RMXAL) GO TO 47
            IF (DABS(RA1(I1)-RMXAL).LT.CONLV1) GO TO 47
            NPTS=NPTS+1
            SX(NPTS)=RA1(I1)
            SY(NPTS)=ASM*(RA1(I1)**PSM)*DEXP(-QSM*RA1(I1))
 47         CONTINUE
         ENDDO
         RMXAL=SX(NPTS)

C *    
C * FIND BEST LEADING POWER OF R FOR ALAM DATA NEAR ORIGIN
C *    
C * THUS, FOR R APPROX. 0 (I.E. FOR R(1) AND R(2)) ASSUME THAT
C * ALAM(I) = R(I)**POWR TO DETERMINE POWR
C *    
         IY=1

C *
C * Fix to take care of "undefined exponentiation" error message...
C *
C * FIND THE FIRST PAIR OF > 0 POINTS
         DO WHILE (SY(IY).LE.0.0 .OR. SY(IY+1).LE.0.0 .OR. SX(IY).LE.0.0
     $        )
            IY = IY + 1
         ENDDO
         POWR=DLOG(SY(IY+1)/SY(IY))/DLOG(SX(IY+1)/SX(IY))
C * End of Fix

C *
C     IF (SX(1).EQ.0.0) IY=2
C     POWR=DLOG(abs(SY(IY+1)/SY(IY)))/DLOG(SX(IY+1)/SX(IY))
         IPOWR=POWR+0.5D+00
         IF (IPOWR.LT.0) IPOWR=0
         IF (IPOWR.NE.LAMDA) WRITE (OUTPUT,17)

C *    
C * FIT MESH POINTS (R(I) WHERE 1 .LE. I .LE. NPTS) WITH
C * A PIECEWISE MONOTONIC CUBIC
C *    
         CALL MONDER (NPTS,SX,SY,DERIV,H,DELY)
C *    
C * DEFINE COEFFICIENTS FOR THE CUBIC POLYNOMIAL EXPRESSION DEDUCIBLE
C * FROM THE MONOTONIC CUBIC SUBROUTINE MONDER.THUS,IN EVERY INTERVAL
C * J BETWEEN POINTS SX(J) AND SX(J+1) WE HAVE
C * F = C(J,1) + C(J,2)*X + C(J,3)*(X**2) + C(J,4)*(X**3)
C *    
         NPTSM=NPTS-1
         X12=SX(1)**2
         DO I=1,NPTSM
            II=I+1
            HI2=H(I)**2
            HI3=H(I)**3
            FI2=SY(I)/HI2
            FI3=2.0D+00*SY(I)/HI3
            FIP2=SY(II)/HI2
            FIP3=2.0D+00*SY(II)/HI3
            DI=DERIV(I)/HI2
            DIP=DERIV(II)/HI2
            X1=SX(I)
            X2=SX(II)
            X22=SX(II)**2
            C(I,1)=(FIP2+(FIP3-DIP)*X2)*X12+(FI2-(FI3+DI)*X1)*X22
            C(I,2)=(FI3+DI)*X22-(FIP3-DIP)*X12-2.0D+00*FI2*X2-2.0D+00
     $           *FIP2*X1+2.0D+00*(FI3-FIP3+DI+DIP)*X1*X2
            C(I,3)=FI2+FIP2-(FI3+DI-2.0D+00*FIP3+2.0D+00*DIP)*X1-(2.0D
     $           +00*FI3-FIP3+2.0D+00*DI+DIP)*X2
            C(I,4)=FI3-FIP3+DI+DIP
            X12=X22
         ENDDO
         IF (IPRNT.LT.2) GO TO 49
         WRITE (OUTPUT,25)
         WRITE (OUTPUT,2) LAMDA
         WRITE (OUTPUT,3) (SX(J),SY(J),(C(J,I),I=1,4),J=1,NPTSM)
         WRITE (OUTPUT,7) LAMDA,ASM,PSM,QSM
C *    
C * USE PIECEWISE MONOTONIC CUBIC FIT TO ALAM DATA TO GENERATE
C * ALAM AT ALL POINTS OF THE VLAM MESH BETWEEN THE FIRST AND
C * THE LAST RADIAL POINTS OF THE ALAM MESH
C *
    
 49      ID=1
         CALL PWCFEV (ID,NPTS,SX,SY,DERIV,IMAX,RA1,AMAT)
         IC=0
         DO I=1,NREG
            NNN=NH(I)
            DO J=1,NNN
               IC=IC+1
               R=RA1(IC)
               IF (SX(1).LT.CONLV1.AND.DABS(R-SX(2)).LT.CONLV1) GO TO 54
               IF (SX(1).LT.CONLV1.AND.R.GT.SX(2)) GO TO 54
               IF (SX(1).GE.CONLV1.AND.DABS(R-SX(1)).LT.CONLV1) GO TO 54
               IF (SX(1).GE.CONLV1.AND.R.GT.SX(1)) GO TO 54
C *    
C * USE POWER SERIES (LEADING ORDER IPOWR TIMES POLYNOMIAL
C * OF ORDER NFIT-1) FIT NEAR ORIGIN (EITHER BETWEEN 0.0
C * AND SX(1) IF SX(1) .GT. 0.0 OR BETWEEN 0.0 AND SX(2)
C * IF SX(1) = 0.0)
C *    
C * ALAM(I) = EXPN(1)*R(I)**IPOWR + EXPN(2)*R(I)**(IPOWR+1) + ETC.
C *    
C * FIND POWER SERIES OF ORDER NFIT-1 FROM FIRST NFIT POINTS
C * (WITH NON-ZERO RADIAL VALUES)
C *    
C * USES MODIFIED ARGONNE LINPACK SUBROUTINES SGEFA AND SGESL
C *   
               KM=NFIT
               IE=0
               IF (SX(1).LT.CONLV1) IE=1
               DO IA=1,KM
                  IAP=IA+IE
                  RHO=SX(IAP)
                  X=RHO**IPOWR
                  EXPN(IA)=SY(IAP)
                  DO JA=1,KM
                     ARRY(IA,JA)=X
                     X=X*RHO
                  ENDDO
               ENDDO
               NDA=MXPR+1
               CALL SGEFA (ARRY,NDA,KM,IPVT,INFO)
               IF (INFO.NE.0) WRITE (OUTPUT,37)
               CALL SGESL (ARRY,NDA,KM,IPVT,EXPN)
               AMAT(IC)=0.0D+00
               IF (R.GE.CONLV1) GO TO 52
               IF (LAMDA.NE.0) GO TO 54
               AMAT(IC)=EXPN(1)
               GO TO 54
 52            RP=R
               X=RP
               RP=X**IPOWR
               DO IX=1,NFIT
                  AMAT(IC)=AMAT(IC)+EXPN(IX)*RP
                  RP=RP*X
               ENDDO
 54            AMAT(IC)=FPOVL*AMAT(IC)
            ENDDO
         ENDDO
         IF (SY(1).GE.CONLV1.AND.SX(1).LT.CONLV1.AND.LAMDA.GT.0) WRITE
     $        (OUTPUT,38) LAMDA
         IF (DABS(SY(1)-EXPN(1)).GE.CONLV1.AND.SX(1).LT.CONLV1.AND.LAMDA
     $        .EQ.0) WRITE (OUTPUT,39) EXPN(1),CONLV1,SY(1)
         WRITE (OUTPUT,4) LAMDA,NFIT,IPOWR,(EXPN(IB),IB=1,KM)
         WRITE (OUTPUT,5)

C *    
C * EVALUATE THE ANALYTICAL EXPRESSION FOR
C * BMAT(I) = R(I)**(-(LAMDA+1))*INTEGRAL(DX FROM 0 TO R(I))
C * OF (A(X)*X**2)*X**(LAMDA)
C * + R(I)**(LAMDA)*INTEGRAL(DX FROM R(I) TO RMAX)
C * OF (A(X)*X**2)/(X**(LAMDA+1))
C *    
C * DETERMINE THE ARRAY ,INTRVL(J), SUCH THAT VLAM MESH POINT
C * RA1(J) LIES IN INTERVAL ,INTRVL(J), OF THE INPUT ALAM MESH
C *    
         IF (IPRNT.GE.3) WRITE (OUTPUT,34)
         JK=1
         IMAXM=IMAX-1
         DO II=1,IMAX
            INTRVL(II)=0
            DO J=JK,NPTS
               JJ=J
               IF (RA1(II).GT.SX(J)) GO TO 56
               IF (DABS(SX(J)-RA1(II)).LT.CONLV1) GO TO 56
               INTRVL(II)=J-1
               IF (IPRNT.LT.3) GO TO 57
               WRITE (OUTPUT,35) II,RA1(II),INTRVL(II)
               GO TO 57
 56            CONTINUE
            ENDDO
 57         JK=JJ
         ENDDO
         IF (DABS(RMAX-RMXAL).LT.CONLV1) INTRVL(IMAX)=INTRVL(IMAXM)+1

C * EVALUATE THE INTEGRAL FROM 0 TO R

         IF (IPRNT.LT.3) GO TO 59
         WRITE (OUTPUT,36)
 59      N=LAMDA+2
         YMAT(1)=0.0D+00
         BMAT(1)=0.0D+00
         IF (RA1(1).LT.CONLV1) GO TO 60
         XL=0.0D+00
         XU=RA1(1)
         CALL CUBINT (XL,XU,1,N,CINT)
         YMAT(1)=CINT
         BMAT(1)=(XU**(-(N-1)))*YMAT(1)
 60      DO I=1,IMAXM
            II=I+1
            XL=RA1(I)
            XU=RA1(II)
            CALL CUBINT (XL,XU,I,N,CINT)
            YMAT(II)=YMAT(I)+CINT
            BMAT(II)=(XU**(-(N-1)))*YMAT(II)
         ENDDO

C * Y1 = COEFFICIENT OF R**(-(LAMDA+1)) AT LAST POINT

         Y1=FPOVL*YMAT(IMAX)

C * EVALUATE INTEGRAL FROM R TO RMXAL, ADD INTEGRAL FROM 0 TO R

         N=-(LAMDA+1)+2
         YMAT(IMAX)=0.0D+00
         IF (DABS(RMAX-RMXAL).LT.CONLV1) GO TO 62
         XL=RMAX
         XU=RMXAL
         CALL CUBINT (XL,XU,IMAX,N,CINT)
         YMAT(IMAX)=CINT
         BMAT(IMAX)=(XL**(-(N-1)))*YMAT(IMAX)+BMAT(IMAX)
 62      DO I=1,IMAXM
            IP=IMAX+1-I
            IPP=IP-1
            XL=RA1(IPP)
            XU=RA1(IP)
            CALL CUBINT (XL,XU,IPP,N,CINT)
            YMAT(IPP)=YMAT(IP)+CINT
            IF (N.NE.1) GO TO 63
            BMAT(IPP)=YMAT(IPP)+BMAT(IPP)
            GO TO 64
 63         BMAT(IPP)=(XL**(-(N-1)))*YMAT(IPP)+BMAT(IPP)
 64         CONTINUE
         ENDDO

C * Y2 = COEFFICIENT OF R**LAMDA AT ORIGIN

         Y2=FPOVL*YMAT(1)
         DO IK=1,IMAX
            BMAT(IK)=FPOVL*BMAT(IK)
            HOLD(IK)=BMAT(IK)
         ENDDO
C *
C * CALCULATE NUCLEAR CONTRIBUTION
C *    
C * COEF1 W/ LAMDA .EQ. 0 = FRACTION OF EXACT TOTAL CHARGE
C * FROM 0.0D+00 TO RMAX
C * COEF2 W/ LAMDA .EQ. 0 = FRACTION OF EXACT TOTAL CHARGE
C * FROM RMAX TO INFINITY
C * COEF3 W/ LAMDA .EQ. 0 = TOTAL CALCULATED ELECTRONIC CHARGE
C *    
         IF (ICASE.EQ.2) GO TO 71
         COEF1=1.0D+00
         COEF2=0.0D+00
         IF (LAMDA.GT.0) GO TO 66
         COEF1=Y1
         LAMDA=-1
         CALL DQL16 (F6)
         LAMDA=0
         COEF2=(ASM/QSM)*DEXP(-QSM*RMAX)*F6*FPOVL
         COEF3=COEF1+COEF2
         COEF1=COEF1/ZN
         COEF2=COEF2/ZN
 66      DO IK=1,IMAX
            R=RA1(IK)
            VZ=0.0D+00
            DO IJ=1,NCT
               RZ=RJ(IJ)
               ZZ=ZJ(IJ)
               CN=1.0D+00
               IF (RZ.LT.0.0D+00) CN=(-1.0D+00)**LAMDA
               RZ=DABS(RZ)
               RZG=DMAX1(RZ,R)
               RZL=DMIN1(RZ,R)
               IF (RZG.GT.0.0D+00) GO TO 67
               VZ=-GOOGOL
               WRITE (OUTPUT,23)
               GO TO 69
 67            IF (LAMDA.NE.0) GO TO 68
               VZ=VZ-ZZ*CN/RZG
               GO TO 69
 68            VZ=VZ-ZZ*CN*(((RZL/RZG)**LAMDA)/RZG)
 69            CONTINUE
            ENDDO
            BMAT(IK)=(BMAT(IK)+VZ*COEF1)+VZ*COEF2
         ENDDO

C *    
C * INTEGRATE FROM RMAX TO INFINITY
C *    
C * COEF = COEFFICIENT OF R**LAMDA FROM RMAX TO INFINITY
C *
    
 71      CALL DQL16 (F6)
         COEF=FPOVL*(ASM/QSM)*DEXP(-QSM*RMAX)*F6
         DO IK=1,IMAX
            R=RA1(IK)
            IF (LAMDA.EQ.0) R=1.0D+00
            BMAT(IK)=BMAT(IK)+COEF*R**LAMDA
         ENDDO

C *    
C * COMPUTE MULTIPOLE MOMENTS AT RMAX AND INFINITY
C *    
C * COEF1 W/ LAMDA .GT. 0 = MULTIPOLE POLARIZABILITY AT RMAX
C * COEF3 W/ LAMDA .GT. 0 = TOTAL CALCULATED MULTIPOLE POLARIZABILITY
C *    
         IF (LAMDA.EQ.0) GO TO 73
         COEF1=BMAT(IMAX)*RMAX**(LAMDA+1)
         LAMDA=-LAMDA-1
         CALL DQL16 (F6)
         LAMDA=-LAMDA-1
         COEF2=FPOVL*F6*(ASM/QSM)*DEXP(-QSM*RMAX)
         IF (ICASE.EQ.2) VZ=0.0D+00
         COEF3=Y1+COEF2+VZ*RMAX**(LAMDA+1)
 73      DO IK=1,IMAX
            VPOT1(IK)=BMAT(IK)
         ENDDO
         IF (IPRNT.EQ.0) GO TO 76
         IF (IPRNT.GE.2) WRITE (OUTPUT,25)
         WRITE (OUTPUT,26) LAMDA
         IF (IFLG.EQ.0) GO TO 75
         WRITE (OUTPUT,28) (RA1(MIT),AMAT(MIT),HOLD(MIT),VPOT1(MIT),MIT
     $        =1,IMAX,IFLG)
 75      CONTINUE
         WRITE (OUTPUT,30) Y2,Y1
         WRITE (OUTPUT,32) COEF
         IF (ICASE.EQ.1.AND.LAMDA.EQ.0) WRITE (OUTPUT,31) COEF1,COEF2
     $        ,COEF3
         COEF1=-COEF1
         COEF3=-COEF3
         IF (ICASE.EQ.1.AND.LAMDA.GT.0) WRITE (OUTPUT,33) COEF1,COEF3
 76      WRITE (OUNIT,27) (RA1(MIT),VPOT1(MIT),MIT=2,IMAX)
 77   CONTINUE

C *
C * ERROR DIAGNOSTICS PRINT OUT
C *
    
      STOP
 78   WRITE (OUTPUT,18)
      STOP
 79   WRITE (OUTPUT,19)
      STOP
 80   WRITE (OUTPUT,20)
      STOP
 81   WRITE (OUTPUT,22) RMAX,RMXAL
      STOP
 82   WRITE (OUTPUT,24) LAMDA
      STOP
      END

C *-
C *
C * SUBROUTINE SGEFA FACTORS THE MATRIX, A(NDA,N) ,INTO LU-FORM WHERE
C * L = LOWER TRIANGULAR MATRIX
C * U = UPPER TRIANGULAR MATRIX
C *
C * IPVT = PIVOT INFORMATION PARAMETER
C * INFO = DIAGNOSTIC PARAMETER
C *      = 0 IMPLIES THAT SGESL MAY BE SAFELY USED
C *
C * REF. MODIFIED VERSION OF ARGONNE NATIONAL LAB.-LINPACK WORKING
C * NOTE NO. 9 (1977) PP. 1.3-1.4
C *
C * A(NDA,N) = R(NDA)**(IPOWR+N-1)
C *

      SUBROUTINE SGEFA (A,NDA,N,IPVT,INFO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NDA,1), IPVT(1)

      INFO=0
      IF (N.GT.1) GO TO 1
      IF (A(1,1).NE.0.0D+00) A(1,1)=1.0D+00/A(1,1)
      IF (A(1,1).EQ.0.0D+00) INFO=1
      RETURN
    1 N1=N-1
      DO I=1,N1
         I1=I+1
         M=I
         DO K=I1,N
            IF (DABS(A(K,I)).GT.DABS(A(M,I))) M=K
         ENDDO
         IPVT(I)=M
         P=A(M,I)
         IF (P.EQ.0.0D+00) GO TO 8
         IF (M.EQ.I) GO TO 4
         A(M,I)=A(I,I)
         DO K=I1,N
            T=A(I,K)
            A(I,K)=A(M,K)
            A(M,K)=T
         ENDDO
 4       RP=1.0D+00/P
         A(I,I)=RP
         DO K=I1,N
            A(K,I)=A(K,I)*RP
         ENDDO
         DO J=I1,N
            C=A(I,J)
            IF (C.EQ.0.0D+00) GO TO 7
            DO K=I1,N
               A(K,J)=A(K,J)-A(K,I)*C
            ENDDO
 7          CONTINUE
         ENDDO
      ENDDO
      IF (A(N,N).NE.0.0D+00) A(N,N)=1.0D+00/A(N,N)
      IF (A(N,N).EQ.0.0D+00) INFO=N
      RETURN
    8 INFO=I
      RETURN
      END

C *-
C *
C * SUBROUTINE SGESL TAKES THE LU-FACTORED MATRIX, A(NDA,N) ,AND
C * SOLVES FOR X WHERE AX = B. ON RETURN B CONTAINS THE SOLUTION X.
C *
C * IPVT = PIVOT INFORMATION PARAMETER
C *
C * REF. MODIFIED VERSION OF ARGONNE NATIONAL LAB.-LINPACK WORKING
C * NOTE NO. 9 (1977) PP. 1.4-1.6
C *
C *
C * A(NDA,N) = R(NDA)**(IPOWR+N-1)
C *
C * COMING IN
C *   B(I) = ALAM(I)
C *   THE X(I))S ARE AS YET UNKNOWN COEFFICIENTS
C * GOING OUT
C *   B(I) = X(I)
C *   FROM THE EXPANSION 0 ALAM(I) = X(1)*R(I)**IPOWR
C *   + X(2)*R(I)**(IPOWR+1) + X(3)*R(I)**(IPOWR+2) + ETC.
C *

      SUBROUTINE SGESL (A,NDA,N,IPVT,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NDA,1), B(1), IPVT(1)

      IF (N.GT.1) GO TO 1
      B(1)=B(1)*A(1,1)
      RETURN
    1 N1=N-1
      DO I=1,N1
         I1=I+1
         M=IPVT(I)
         IF (M.EQ.I) GO TO 2
         T=B(M)
         B(M)=B(I)
         B(I)=T
 2       C=B(I)
         IF (C.EQ.0.0D+00) GO TO 4
         DO K=I1,N
            B(K)=B(K)-A(K,I)*C
         ENDDO
 4       CONTINUE
      ENDDO
      DO I=1,N1
         J=N-I+1
         J1=J-1
         B(J)=B(J)*A(J,J)
         C=B(J)
         IF (C.EQ.0.0D+00) GO TO 6
         DO K=1,J1
            B(K)=B(K)-A(K,J)*C
         ENDDO
 6       CONTINUE
      ENDDO
      B(1)=B(1)*A(1,1)
      RETURN
      END

C *-
C *
C * MONDER USES THE FRITSCH-CARLSON FORUMLAS TO SET DERIVATIVE
C * VALUES FOR A PIECEWISE CUBIC INTERPOLANT TO THE DATA (X, F)
C * SO THAT THE INTERPOLANT IS MONOTONE ON ANY SUBINTERVAL ON
C * WHICH THE DATA ARE MONOTONE.
C *
C * THIS VERSION USES\
C *   1. THREE-POINT DIFFERENCE FORMULAS TO INITIALIZE DERIVATIVES
C *      (INCLUDING ENDPOINTS).
C *   2. REGION S(3).
C *   3. ALGORITHM A FOR MOVING A POINT INTO REGION.
C *   4. ANY NEGATIVE ALPHA OR BETA (INDICATING A CHANGE IN MONO-
C *      TONICITY OF THE DATA) IS SET TO ZERO TO INSURE THE STRICT
C *      PIECEWISE MONOTONICITY OF THE INTERPOLANT.
C *
C * SUBROUTINE PWCFEV MAY BE USED TO EVALUATE THE RESULTING
C * PIECEWISE CUBIC FUNCTION.
C *
C * REFERENCE\  F. N. FRITSCH AND R. E. CARLSON, PIECEWISE CUBIC
C * INTERPOLATION METHODS, LAWRENCE LIVERMORE LABORATORY REPORT
C * UCRL-81230 (NOVEMBER 1978).
C *
C * ON INPUT\
C *      N      IS THE NUMBER OF DATA POINTS.
C *             RESTRICTION\  N.GE.4  (NOT CHECKED).
C *      X      IS THE ARRAY OF INDEPENDENT VARIABLE VALUES.
C *             RESTRICTION\  X MUST BE STRICTLY INCREASING, THAT IS
C *                X(I) .LT. X(I+1), I=1(1)N-1  (NOT CHECKED).
C *      F      IS THE ARRAY OF DEPENDENT VARIABLE VALUES.
C *
C * ON OUTPUT\
C *      D      WILL BE SET TO THE DESIRED DERIVATIVE VALUES.
C *      H      WILL BE THE ARRAY OF INTERVAL LENGTHS,
C *                H(I) = X(I+1) - X(I), I=1(1)N-1.
C *      SLOPE  WILL BE THE ARRAY OF SLOPES OF CHORDS,
C *                SLOPE(I) = (F(I+1) - F(I))/H(I), I=1(1)N-1.
C *
C * NOTE: ARRAYS H AND SLOPE ARE NO LONGER NEEDED AFTER THE CALL TO
C * MONDER.
C *
C * FORTRAN INTRINSICS USED\  ABS.
C *
C *
C * ALGORITHM BY\  F. N. FRITSCH, LAWRENCE LIVERMORE LABORATORY, AND
C *                R. E. CARLSON, GROVE CITY COLLEGE, PA.
C * PROGRAMMED BY\ F. N. FRITSCH.
C * DATE LAST CHANGED\  11 JANYARY 1979  (FNF)
C *
C * CHANGE RECORD\    0000
C *      78-12-07   MINOR COSMETIC CHANGES TO GET READY FOR LIBRARY.
C *      78-12-20   1. REMOVED ARGUMENT ICOUNT.
C *                 2. CHANGED ARGUMENT Y TO F (TO BE CONSISTENT WITH
C *                    PWCFEV).
C *      79-01-11   1. CHANGED TREATMENT OF INTERVAL ADJACENT TO CHANGE
C *                    IN MONOTONICITY OF DATA (SEE ITEM 4, ABOVE).
C *                 2. MINOR ADDITIONS TO COMMENT SECTION.
C *
C *

      SUBROUTINE MONDER (N,X,F,D,H,SLOPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N
      DOUBLE PRECISION X(N),F(N),D(N),SLOPE(N),H(N)

C * LOCAL DECLARATIONS.

      INTEGER I,NLESS1
      DOUBLE PRECISION ALPHA,BETA,DELTA,FUZZ,TAU
      DATA FUZZ/1.0D-14/

C * INITIALIZE.

      NLESS1=N-1

C * COMPUTE INTERVAL LENGTHS AND SLOPES.

      DO I=1,NLESS1
         H(I)=X(I+1)-X(I)
         SLOPE(I)=(F(I+1)-F(I))/H(I)
      ENDDO

C * INITIALIZE D(1) VIA NON-CENTERED THREE-POINT FORMULA.

      D(1)=((H(1)+H(1)+H(2))*SLOPE(1)-H(1)*SLOPE(2))/(H(1)+H(2))
      IF (D(1)*SLOPE(1).LT.0.0D+00) D(1)=0.0D+00

C * CYCLE THROUGH ALL INTERVALS.

      DO I=1,NLESS1
         IF (I.LT.NLESS1) GO TO 2

C * SPECIAL CASE OF RIGHT ENDPOINT.
         D(N)=((H(N-1)+H(N-1)+H(N-2))*SLOPE(N-1)-H(N-1)*SLOPE(N-2))/(H(N
     $        -2)+H(N-1))
         IF (D(N)*SLOPE(N-1).LT.0.0D+00) D(N)=0.0D+00
         GO TO 3
 2       CONTINUE

C * USE THREE-POINT FORMULA TO INITIALIZE RIGHT-HAND
C * DERIVATIVE FOR INTERVAL (X(I), X(I+1)) .

         D(I+1)=(H(I+1)*SLOPE(I)+H(I)*SLOPE(I+1))/(H(I)+H(I+1))

 3       CONTINUE

C * ADJUST D(I) AND/OR D(I+1), IF NECESSARY TO INSURE MONOTONICITY
C * ON INTERVAL (X(I), X(I+1)) .
C *
C * TAKE CARE OF FLAT DATA.
C *
         IF (DABS(SLOPE(I)).GT.FUZZ) GO TO 4
         ALPHA=0.0D+00
         BETA=0.0D+00
         GO TO 5
 4       CONTINUE

C * COMPUTE SCALED DERIVATIVES.

         ALPHA=D(I)/SLOPE(I)
         BETA=D(I+1)/SLOPE(I)
C *
C * TAKE CARE OF NONMONOTONE DATA.
C *
C * ASSERTION\  IF EITHER OF THE FOLLOWING TESTS IS SATISFIED,
C *             (ALPHA,BETA) IS NOT IN FIRST QUADRANT, WHICH
C *             MEANS THAT SLOPE CHANGES SIGN AT ONE OR BOTH ENDS
C *             OF INTERVAL.

         IF (ALPHA.LT.0.0D+00) ALPHA=0.0D+00
         IF (BETA.LT.0.0D+00) BETA=0.0D+00

C * ASSERTION\  ALPHA AND BETA ARE NOW BOTH NONNEGATIVE.
C *
C * MAKE    ALPHA + BETA .LE. 3 .
C *
         DELTA=ALPHA+BETA
         IF (DELTA.LE.3.0D+00) GO TO 5
C * ASSERTION\  POINT IS OUTSIDE THE TRIANGLE.  NEED TO ADJUST.
         TAU=3.0D+00/DELTA
         ALPHA=TAU*ALPHA
         BETA=TAU*BETA

C * RECOMPUTE DERIVATIVE VALUES.

 5       CONTINUE
         D(I)=ALPHA*SLOPE(I)
         D(I+1)=BETA*SLOPE(I)

      ENDDO

C * END OF DERIVATIVE ASSIGNMENT.

      RETURN
      END

C *-
C *
C * EVALUATE THE FIRST (IDERIV-1) DERIVATIVES OF THE PIECEWISE
C * CUBIC FUNCTION DEFINED BY  N, X, F, D  AT THE POINTS  XE(I),
C * I = 1(1)NE.
C *
C * ON INPUT\
C *      IDERIV  INDICATES HOW MANY DERIVATIVES ARE DESIRED.
C *              RESTRICTION\  1 .LE. IDERIV .LE. 3 (NOT CHECKED).
C *              NOTE\  IDERIV=1 IMPLIES ONLY FUNCTION VALUES REQUESTED.
C *      N       IS THE NUMBER OF DATA POINTS.
C *              RESTRICTION\  N .GE. 2  (NOT CHECKED).
C *      X       IS THE ARRAY OF INDEPENDENT VARIABLE VALUES.
C *              THE SEARCH PROCEDURE ASSUMES THAT X IS STRICTLY
C *              INCREASING.  (NOT CHECKED)
C *      F       IS THE CORRESPONDING ARRAY OF FUNCTION VALUES.
C *      D       IS THE CORRESPONDING ARRAY OF DERIVATIVE VALUES.
C *      NE      IS THE NUMBER OF POINTS AT WHICH EVALUATION IS DESIRED.
C *      XE      IS THE ARRAY OF EVALUATION POINTS.
C *              THE SEARCH PROCEDURE ASSUMES THAT XE IS MONOTONE
C *              INCREASING.  (NOT CHECKED)
C *
C * ON RETURN.
C *      FE      CONTAINS THE FUNCTION VALUES, AS FOLLOWS.
C *              FE(I,J)  IS THE VALUE OF THE (J-1)-ST DERIVATIVE OF
C *                       THE PIECEWISE CUBIC AT XE(I), I=1(1)NE,
C *                       J=1(1)IDERIV.
C *
C * OTHER ROUTINES USED\  HBASEV, SEARCH.
C *
C * ALGORITHM BY\  F. N. FRITSCH, LAWRENCE LIVERMORE LABORATORY,
C *                R. E. CARLSON, GROVE CITY COLLEGE, PA.,  AND
C *                R. P. DICKINSON, JR., CHABOT COLLEGE.
C * PROGRAMMED BY\ F. N. FRITSCH.
C * DATE LAST CHANGED\  22 DECEMBER 1978 (FNF)
C *
C * CHANGE RECORD\
C *      78-12-07   MINOR COSMETIC CHANGES TO GET READY FOR LIBRARY.
C *      78-12-21   MINOR MODIFICATIONS TO SEARCH ROUTINE.
C *      78-12-22   CHANGED TO UNNORMALIZED HERMITE BASIS FUNCTIONS.
C *                 ALSO CHANGED ARGUMENT NAME YE TO FE.
C *

      SUBROUTINE PWCFEV (IDERIV,N,X,F,D,NE,XE,FE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER IDERIV,N,NE
      DOUBLE PRECISION X(N),F(N),D(N),XE(NE),FE(NE,IDERIV)

C * LOCAL DECLARATIONS.

      INTEGER I,IER,IL
      DOUBLE PRECISION H(4,3)

C * MAIN EVALUATION LOOP.

      IL=0
      DO I=1,NE

C * LOCATE INTERVAL CONTAINING XE(I).

         CALL SEARCH (N,X,XE(I),IL,IER)

C * EVALUATE HERMITE BASIS FUNCTIONS AND NEEDED DERIVATIVES.

         CALL HBASEV (IDERIV,X(IL),X(IL+1),XE(I),H)

C * EVALUATE CUBIC AND APPROPRIATE DERIVATIVES.

         DO ID=1,IDERIV
            FE(I,ID)=F(IL)*H(1,ID)+F(IL+1)*H(2,ID)+D(IL)*H(3,ID)+D(IL+1)
     $           *H(4,ID)
         ENDDO

      ENDDO

      RETURN
      END
 
C *-
C *
C * SEARCH FOR XVAL IN ARRAY X.
C *
C * PERFORMS A LINEAR SEARCH, FROM LEFT TO RIGHT.   FOR IMPROVED
C * EFFICIENCY WHEN LOCATING AN INCREASING SEQUENCE OF XVAL)S,
C * THE STARTING INDEX FOR THE SEARCH MAY BE SPECIFIED BY THE USER.
C *
C *
C * ON INPUT\
C *      N       IS THE NUMBER OF POINTS IN ARRAY X.
C *              RESTRICTION\  N.GE.2  (NOT CHECKED)
C *      X       IS THE ARRAY OF VALUES TO BE SEARCHED.
C *              X IS ASSUMED TO BE STRICTLY INCREASING. (NOT CHECKED)
C *      XVAL    IS THE VALUE BEING SEARCHED FOR.
C *      IL      IS THE INDEX AT WHICH THE SEARCH IS TO BEGIN.
C *              TO INITIALIZE THE SEARCH, SET IL.LE.1 .
C *
C * ON RETURN\
C *      IL      IS THE INDEX SUCH THAT
C *
C *              X(IL) .LT. XVAL .LE. X(IL+1) .
C *
C *      IER     IS AN ERROR FLAG, WITH THE FOLLOWING MEANING.
C *              IER =-1  IF XVAL .LT. X(1).  IN THIS CASE IL=1 ON
C *                       RETURN.
C *               IER = 0  IF X(1) .LE. XVAL .LE. X(N).  (NORMAL RETURN)
C *               IER = 1  IF XVAL .GT. X(N) .  IN THIS CASE IL=N-1 ON
C *                        RETURN.
C *
C * NOTES\
C *      1.  IF  XVAL.EQ.X(1), THE RETURNED VALUES ARE  IL=1, IER=0.
C *      2.  IER AND THE THREE LINES THAT SET ITS VALUE MAY
C *          BE DELETED IF THE USER DOES NOT WISH TO BE NOTIFIED
C *          ABOUT EXTRAPOLATION.
C *
C * FORTRAN INTRINSICS USED\  MAX0, MIN0.
C *
C * PROGRAMMED BY\  F. N. FRITSCH, MSS, LAWRENCE LIVERMORE LABORATORY.
C * DATE LAST CHANGED\  21 DECEMBER 1978 (FNF).
C *
C * CHANGE RECORD\
C *      78-12-21   MODIFIED TO REINITIALIZE SEARCH IF XVAL.LE.X(IL).

      SUBROUTINE SEARCH (N,X,XVAL,IL,IER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER N,IL,IER
      DOUBLE PRECISION X(N),XVAL

C * LOCAL DECLARATIONS.

      INTEGER I,IMIN

C * ADJUST IL SO THAT  1 .LE. IL .LT. N .

      IL=MAX0(IL,1)
      IL=MIN0(IL,N-1)

C * CHECK WHETHER SEARCH SHOULD BE REINITIALIZED.

      IF (XVAL.GT.X(IL)) GO TO 1
      IL=1

C * CHECK FOR EXTRAPOLATION TO THE LEFT.

      IF (XVAL.GE.X(1)) GO TO 1
      IER=-1
      RETURN

C * NORMAL CASE.

    1 CONTINUE
      IMIN=IL+1
      DO I=IMIN,N
         IF (XVAL.GT.X(I)) GO TO 2
         IL=I-1
         IER=0
         RETURN
 2       CONTINUE
      ENDDO

C * EXTRAPOLATION TO THE RIGHT.

      IL=N-1
      IER=1
      RETURN

      END

C *-
C *
C * EVALUATE THE HERMITE BASIS FUNCTIONS FOR (X1,X2) AND THEIR
C * FIRST (IDERIV-1) DERIVATIVES AT X.
C *
C * ON INPUT\
C *      IDERIV  IS THE NUMBER OF FUNCTIONS TO BE EVALUATED.
C *              IT IS ASSUMED THAT IDERIV = 1, 2, OR 3.  (NOT CHECKED)
C *      X1,X2   ARE THE ENDPOINTS OF THE INTERVAL ON WHICH THE BASIS
C *              FUNCTIONS ARE DEFINED.
C *      X       IS THE POINT AT WHICH FUNCTIONS ARE TO BE EVALUATED.
C *              GENERALLY X1.LE.X.LE.X2, ALTHOUGH THIS IS NOT REQUIRED.
C *
C * ON OUTPUT\
C *      HVALUE  WILL CONTAIN THE DESIRED FUNCTION VALUES, AS FOLLOWS.
C *
C *               HVALUE(I,1) = H(I,X)                       )
C *               HVALUE(I,2) = (D/DX) H(I,X)  (IDERIV.GE.2) )  I=1(1)4.
C *               HVALUE(I,3) = (D/DX)**2 H(I,X)  (IDERIV=3) )
C *
C *              WHERE H(I,X) DENOTES THE I-TH HERMITE BASIS FUNCTION
C *              FOR THE INTERVAL (X1,X2) EVALUATED AT X.
C *
C *
C * ALGORITHM BY\  F. N. FRITSCH, LAWRENCE LIVERMORE LABORATORY,
C *                R. E. CARLSON, GROVE CITY COLLEGE, PA.,  AND
C *                R. P. DICKINSON, JR., CHABOT COLLEGE.
C * PROGRAMMED BY\ F. N. FRITSCH.
C * DATE LAST CHANGED\  22 DECEMBER 1978 (FNF)
C *
C * CHANGE RECORD\
C *      78-12-21   MINOR COSMETIC CHANGES TO GET READY FOR LIBRARY.
C *      78-12-22   CHANGED FROM THE NORMALIZED INTERVAL (0,1) TO AN
C *                 ARBITRARY INTERVAL (X1,X2). THIS REQUIRED REPLACING
C *                 ARGUMENT T BY THREE ARGUMENTS X1, X2, X.
C *

      SUBROUTINE HBASEV (IDERIV,X1,X2,X,HVALUE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER IDERIV
      DOUBLE PRECISION X1,X2,X,HVALUE(4,IDERIV)

C * LOCAL DECLARATIONS.

      DOUBLE PRECISION H,RH,T,TT,TTU,TUU,U,UU

C * INITIALIZE

      H=X2-X1
      RH=1.0D+00/H
      T=(X-X1)*RH
      U=(X2-X)*RH

C * EVALUATE BASIS FUNCTIONS.

      TT=T*T
      UU=U*U
      TTU=TT*U
      TUU=T*UU
      HVALUE(1,1)=TUU+TUU+UU
      HVALUE(2,1)=TTU+TTU+TT
      HVALUE(3,1)=TUU*H
      HVALUE(4,1)=-TTU*H

C * NOTE..  IF DERIVATIVES WILL NEVER BE NEEDED, MAY
C *         DELETE FROM HERE TO (BUT NOT INCLUDING) THE FINAL
C *         RETURN STATEMENT.
C *         MAY ALSO DELETE ARGUMENT IDERIV AND THE SECOND
C *         INDEX OF HVALUE IN THIS CASE.

      IF (IDERIV.EQ.1) RETURN

C * EVALUATE FIRST DERIVATIVES.

      HVALUE(2,2)=6.0D+00*T*U*RH
      HVALUE(1,2)=-HVALUE(2,2)
      TTU=T+T-U
      TUU=T-U-U
      HVALUE(3,2)=-U*TTU
      HVALUE(4,2)=T*TUU

C * NOTE..  IF SECOND DERIVATIVES WILL NEVER BE NEEDED, MAY
C *         DELETE FROM HERE TO (BUT NOT INCLUDING) THE FINAL
C *         RETURN STATEMENT.

      IF (IDERIV.EQ.2) RETURN

C * COMPUTE SECOND DERIVATIVES.

      HVALUE(2,3)=6.0D+00*(U-T)*RH*RH
      HVALUE(1,3)=-HVALUE(2,3)
      HVALUE(3,3)=2.0D+00*TUU*RH
      HVALUE(4,3)=2.0D+00*TTU*RH
      RETURN

      END

C *-
C *
C * EVALUATES THE ANALYTICAL EXPRESSION ,CINT, FOR THE INTEGRAL
C * (DX FROM XL TO XU) OF (X**N)*(C(J,1) + C(J,2)*X
C *                        + C(J,3)*X**2 + C(J,4)*X**3)
C *
C * I IS AN INDEX LABELLING THE POINT XL FROM AMONGST A SEQUENCE
C * OF LIMIT POINTS
C *
C * J IS AN INDEX LABELLING THE INTERVAL BEGINNING WITH POINT SX(J)
C * WITHIN WHICH THE POINTS XL AND XU LIE. THE LOGIC HANDLES THE
C * CASES WHEN XL AND XU LIE IN DIFFERENT INTERVALS.
C *

      SUBROUTINE CUBINT (XL,XU,I,N,CINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C     DIMENSION C(MXAL,MXPR+1),INTRVL(MXVL),SX(MXAL)
      DIMENSION C(700,5), INTRVL(700), SX(700)

      COMMON /IINT/ C,SX,CONLV1,CONLV2,INTRVL,NFIT

      II=I+1

C * DETERMINE HOW MANY INTERVALS ,NNTRVL, OF THE SPLINE-FITTED
C * FUNCTION LIE BETWEEN XL AND XU

      NNTRVL=INTRVL(II)-INTRVL(I)
      CINT=0.0D+00
      IF (NNTRVL.EQ.0) GO TO 3
      IF (NNTRVL.EQ.1) GO TO 4
      XLP=XL
      J=INTRVL(I)
      XLP=XL
      XUP=SX(J+1)
      IF ((XUP-XLP).LT.CONLV2*(XU-XL)) GO TO 1
      CALL DOINT (XLP,XUP,J,N,CINTP)
      CINT=CINT+CINTP
    1 NINTM=NNTRVL-1
      DO K=1,NINTM
         J=J+1
         XLP=SX(J)
         XUP=SX(J+1)
         CALL DOINT (XLP,XUP,J,N,CINTP)
         CINT=CINT+CINTP
      ENDDO
      J=J+1
      XLP=SX(J)
      XUP=XU
      IF ((XUP-XLP).LT.CONLV2*(XU-XL)) GO TO 6
      CALL DOINT (XLP,XUP,J,N,CINTP)
      CINT=CINT+CINTP
      GO TO 6
    3 J=INTRVL(I)
      CALL DOINT (XL,XU,J,N,CINTP)
      CINT=CINT+CINTP
      GO TO 6
    4 J=INTRVL(I)
      XLP=XL
      XUP=SX(J+1)
      IF ((XUP-XLP).LT.CONLV2*(XU-XL)) GO TO 5
      CALL DOINT (XLP,XUP,J,N,CINTP)
      CINT=CINT+CINTP
    5 J=J+1
      XLP=XUP
      XUP=XU
      IF ((XUP-XLP).LT.CONLV2*(XU-XL)) GO TO 6
      CALL DOINT (XLP,XUP,J,N,CINTP)
      CINT=CINT+CINTP
    6 RETURN
      END

C *-
C *
C * SUBROUTINE TO ACTUALLY EVALUATE THE ANALYTICAL EXPRESSION
C * OF THE INTEGRAL GIVEN IN SUBROUTINE CUBINT ON THE SUBINTERVAL
C * XUP - XLP
C *

      SUBROUTINE DOINT (XLP,XUP,J,N,CINTP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

C     DIMENSION EXPN(MXPR+1),C(MXAL,MXPR+1),INTRVL(MXVL),SX(MXAL)
C               COEFF(MXPR+1)
      DIMENSION EXPN(5), C(700,5), INTRVL(700), SX(700), COEFF(5)

      COMMON /TZ/ EXPN,IPOWR
      COMMON /IINT/ C,SX,CONLV1,CONLV2,INTRVL,NFIT
      COMMON /PRINT/ OUTPUT,IPRNT

      INTEGER OUTPUT

      SUMU=0.0D+00
      SUML=0.0D+00

C *
C * ALL STATEMENTS ENCLOSED BY TTTT... HAVE BEEN ADDED IN AN
C * ATTEMPT TO AVOID (0.0D+00)**-INTEGER ERROR. TOM GIBSON 7/1/79
C *
      NO=N
      NTERMS=4
      IF (J.GT.1) GO TO 1
      IF (J.EQ.1.AND.SX(1).GE.CONLV1) GO TO 1
      N=N+IPOWR
      NTERMS=NFIT
      IF (J.GT.1) WRITE (OUTPUT,8) J,XLP,XUP
    1 DO L=1,NTERMS
         COEFF(L)=C(J,L)
         IF (J.EQ.0) COEFF(L)=EXPN(L)
         IF (J.EQ.1.AND.SX(1).LT.CONLV1) COEFF(L)=EXPN(L)
         IF (IPRNT.LT.3) GO TO 2
         WRITE (OUTPUT,6) XLP,XUP,N,J,L,COEFF(L)
 2       CONTINUE
         IF (N.LT.-NTERMS.OR.N.GT.-1) GO TO 4
         IF (L.NE.-N) GO TO 4
         SUMU=SUMU+COEFF(L)*DLOG(XUP)
         IF (XLP.GE.CONLV1) GO TO 3
         WRITE (OUTPUT,9)
         GO TO 10
 3       SUML=SUML+COEFF(L)*DLOG(XLP)
         GO TO 5
 4       SUMU=SUMU+COEFF(L)*(XUP**(N+L))/(N+L)
         IF(XLP .EQ. 0.0D+00) GO TO 11
         SUML=SUML+COEFF(L)*(XLP**(N+L))/(N+L)
         GO TO 5
 11      SUML=SUMU
 5       CONTINUE
      ENDDO
      CINTP=SUMU-SUML
      IF (IPRNT.LT.3) GO TO 10
      WRITE (OUTPUT,7) CINTP
    6 FORMAT (2D20.12,2X,I5,5X,I5,5X,I5,3X,D20.12)
    7 FORMAT (10X,'CINTP = ',D20.12)
    8 FORMAT (//10X,'VLAM MESH SEQUENCING SCREWED UP ',//,10X,'J = ',I5
     $     ,10X,'XLP = ',F10.5,10X,'XUP = ',F10.5,//)
    9 FORMAT (//10X,'*WARNING* VLAM INTEGRAND DIVERGENT')
 10   N=NO
      RETURN
      END

C *-
      DOUBLE PRECISION FUNCTION FCT(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON /TY/ ASM,PSM,QSM,RMXAL,RMAX,LAMDA
      FCT=(X/QSM+RMAX)**(-LAMDA+(int(PSM))+1)
      RETURN
      END

C *-
C *
C * SUBROUTINE TO INTEGRATE EXPONENTIAL ALAM FROM RMAX TO INFINITY
C *

      SUBROUTINE DQL16 (Y)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

C * To fix undefined exponentiation...
C * ipsm=int(psm)

      X=.51701160339543318D+02
      Y=.41614623703728552D-21*FCT(X)
      X=.41940452647688333D+02
      Y=Y+.50504737000355128D-17*FCT(X)
      X=.34583398702286626D+02
      Y=Y+.62979670025178678D-14*FCT(X)
      X=.28578729742882140D+02
      Y=Y+.21270790332241030D-11*FCT(X)
      X=.23515905693991909D+02
      Y=Y+.28623502429738816D-09*FCT(X)
      X=.19180156856753135D+02
      Y=Y+.18810248410796732D-07*FCT(X)
      X=.15441527368781617D+02
      Y=Y+.68283193308711996D-06*FCT(X)
      X=.12214223368866159D+02
      Y=Y+.14844586873981299D-04*FCT(X)
      X=.9438314336391939D+01
      Y=Y+.20427191530827846D-03*FCT(X)
      X=.70703385350482341D+01
      Y=Y+.18490709435263109D-02*FCT(X)
      X=.50780186145497679D+01
      Y=Y+.11299900080339453D-01*FCT(X)
      X=.34370866338932066D+01
      Y=Y+.47328928694125219D-01*FCT(X)
      X=.21292836450983806D+01
      Y=Y+.13629693429637754D+00*FCT(X)
      X=.11410577748312269D+01
      Y=Y+.26579577764421415D+00*FCT(X)
      X=.46269632891508083D+00
      Y=Y+.33105785495088417D+00*FCT(X)
      X=.8764941047892784D-01
      Y=Y+.20615171495780099D+00*FCT(X)
      RETURN
      END
      BLOCK DATA
      COMMON /PRINT/ OUTPUT,IPRNT
      INTEGER OUTPUT
      data output/6/
      END

